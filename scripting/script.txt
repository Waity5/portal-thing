-- This is sscript, a scripting langauge made for StEVE (should pick a better name)
-- It is used to get around the 8k character limit

-- The syntax is lua-like but has its oddities due to the symplistic interpreter
-- e.g. using a table and a table.unpack on every function call






initFunc:


objects = {}

nilTable = {}
init = nilTable[1]

grav = {0,-600,0}

walkingSpeed = 150
walkingAccelerate = 10

camRot={0.0001-pi/3,0,0}

verticalLookLimiter = pi/2-0.001
rotateSpeed = 90
angleConvert=pi/180
fov=90*angleConvert

maxRollCorrection = 3
maxThroughPortalSpeed = 1000
itterMax = 3

holdMaxMass = 1/75
holdDistance = 72
holdRange = 100

playerYVelocityOld = 0
overallViewNumber = 0
colourAdjustment = {0.7,1.0,1.2,1.0}

coefficientOfFriction = 1
playerFriction = 1*grav[2]

index = "platform"
conditions = {{0,-8,0},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
platformObject = objects[#objects]
index = "skybox"
conditions = {[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})

index = "portal_orange"
--conditions = {{-64,56,256},[4]={0.5,0,0.5,0},[7]=0,[8]=0}
--conditions = {{0,0,200},[4]={0.5,-0.5,0,0},[7]=0,[8]=0}
conditions = {{-128,56,192},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
portalOrange = objects[#objects]
--portalOrange[17][1] = objects[1]

index = "portal_blue"
conditions = {{64,56,256},[4]={0.5,0,-0.5,0},[7]=0,[8]=0}
--conditions = {{0,300,200},[4]=multQuaternionByQuaternion({norm4({{0.5,0.5,0,0}}),{0,0,1,0}}),[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
portalBlue = objects[#objects]
--portalBlue[17][1] = objects[1]

index = "player_bounding"
conditions = {{-256,64,0},[7]=0.02,[8]=0,[9]=grav}
junk = executeScript({summonObjectFunc})
player = objects[#objects]

index = "cube_large"
conditions = {{128,64,256},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
cube1 = objects[#objects]
portalBlue[17][1] = cube1

conditions = {{-128,64,256},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
cube2 = objects[#objects]
portalOrange[17][1] = cube2

conditions = {{-128,384,384},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
cube3 = objects[#objects]

index = "window"
conditions = {{256,64,128},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})


index = "security_camera"
conditions = {{-213,80,256},[4]={0.5,0,0.5,0},[7]=0.1,[8]=0.001, [10] = {$
{1,{0,0,0},norm4({{1,0,0.2,0}})},$
{2,{0,0,0},norm4({{1,-0.1,0,0}})},$
}}
junk = executeScript({summonObjectFunc})

index = "cube_button"
conditions = {{0,0,-128},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})


index1 = -3
index = "cube"
summonBoxes:
	conditions = {{160,20+(index1+3)*25,index1*64},[7]=0.1,[8]=0.0001,[9]=grav,[10]={{1,{0,20,0},norm4({{0.5,0.5,0,0}})}}}
	junk = executeScript({summonObjectFunc})
	index1 = index1+1
4>index1 ~ summonBoxes

--junk = summonObject({"hump",{{-10,0,0},[7]=0,[8]=0}})

springs = {} -- obj1, obj2, offset1, offset2, desired length, spring rate, dampen rate

exit





tickFunc:

fovTan = tan({fov/2})
screenScale = screenWidth2/fovTan

tickRate=62.5
deltaTime=1/tickRate
--deltaTime = 0


i = #objects
deleteObjectsLoop:
	
	objects[i][18][1] ~ skipDeleteObject
		junk = remove({objects,i})
	1 ~ endDeleteObject
	skipDeleteObject:
		objects[i][18] = {1}
	endDeleteObject:
	i = i-1
i > 0 ~ deleteObjectsLoop



junk = executeScript({playerMovementFunc})

pushForce = 0
pushColour = {}
gB1 = gB({1})
gB1 ~ isGB1
gB3 = gB({3})
gB3 ~ isGB3
gB4 = gB({4})
gB4 ~ isGB4
	
	1 ~ endOfPush
isGB1:
	portalOrange[18][1] = nilVar
	index = "portal_orange"
	conditions = {{-64,56,256},[4]={0.5,0,0.5,0},[7]=0,[8]=0}
	junk = executeScript({summonObjectFunc})
	portalOrange = objects[#objects]
	portalOrange[17][1] = cube2
	1 ~ endOfPush
isGB3:
	portalBlue[18][1] = nilVar
	index = "portal_blue"
	conditions = {{-128,320,384},[4]={0.5,0.5,0,0},[7]=0,[8]=0}
	junk = executeScript({summonObjectFunc})
	portalBlue = objects[#objects]
	portalBlue[17][1] = cube3
	1 ~ endOfPush
isGB4:
	portalOrange[18][1] = nilVar
	index = "portal_orange"
	conditions = {{-128,0,384},[4]=multQuaternionByQuaternion({norm4({{0.5,-0.5,0,0}}),{0,0,1,0}}),[7]=0,[8]=0}
	junk = executeScript({summonObjectFunc})
	portalOrange = objects[#objects]
	portalOrange[17][1] = platformObject
	1 ~ endOfPush
endOfPush:


a=camRot[1]
b=camRot[2]
c_a = cos({a})
s_a = sin({a})
c_b = cos({b})
s_b = sin({b})

--cameraRotationMatrix = {}
--cameraRotationMatrix[1] = {c_a*c_c - s_a*s_b*s_c , 0-c_b*s_c , c_a*s_b*s_c + c_c*s_a}
--cameraRotationMatrix[2] = {c_a*s_c + c_c*s_a*s_b , c_b*c_c , s_a*s_c - c_a*c_c*s_b}
--cameraRotationMatrix[3] = {0-c_b*s_a , s_b , c_a*c_b}


cameraRotationVector = {0-s_a*c_b,s_b,c_a*c_b}

junk = executeScript({playerHoldFunc})


exit





playerMovementFunc:

rotateSpeedCr=rotateSpeed*angleConvert/tickRate
rotateSpeedInv = 1/rotateSpeedCr

--gB31 = gB({31})
--gB31 ~ holdingSpace
--	camPos[1] = camPos[1] + (gN({1})*cos({camRot[1]}) - gN({2})*sin({camRot[1]})) / moveSpeedInv
--	camPos[3] = camPos[3] + (gN({1})*sin({camRot[1]}) + gN({2})*cos({camRot[1]})) / moveSpeedInv
--	maxPushForce = 0.5
--	otherPushColours = 50
--	1 ~ endCamMove
--holdingSpace:
--	camPos[2]=camPos[2] + gN({2}) / moveSpeedInv
--	maxPushForce = 2.5
--	otherPushColours = 0
--endCamMove:
camPos = player[1][1]

playerYVelocity = player[2][2]
playerGrounded = 1 > abs({playerYVelocity-playerYVelocityOld})
playerYVelocityOld = player[2][2]

playerGrounded ~ doPlayerGrounded
1 ~ skipPlayerGrounded
doPlayerGrounded:
	playerVelocity = {player[2][1],0,player[2][3]}
	playerSpeed = dist3({playerVelocity,{0,0,0}}) / (0-(playerFriction*deltaTime))
	playerVelocity = mul3({playerVelocity, 1/(mx({playerSpeed,1}))})
	player[2] = sub3({player[2],playerVelocity})
	
	
	gB({31}) ~ doPlayerJump
	1 ~ skipPlayerGrounded
	doPlayerJump:
		player[2][2] = player[2][2] + 150
skipPlayerGrounded:


wishVelocity = mul3({{gN({1})*cos({camRot[1]}) - (gN({2})*sin({camRot[1]})), 0, gN({1})*sin({camRot[1]}) + (gN({2})*cos({camRot[1]}))}, walkingSpeed})
wishSpeed = dist3({wishVelocity,{0,0,0}})
0.001 > wishSpeed ~ skipPlayerAccelerate
wishVelocity = norm3({wishVelocity})

wishSpeed = mn({wishSpeed,walkingSpeed})
playerGrounded ~ skipAirSpeedCap
	wishSpeed = mn({wishSpeed,30})
skipAirSpeedCap:


currentSpeed = dot3({player[2],wishVelocity})
addSpeed = wishSpeed - currentSpeed

0 > addSpeed ~ skipPlayerAccelerate
	accelSpeed = walkingAccelerate * wishSpeed * deltaTime
	
	addSpeed = mn({accelSpeed, addSpeed})
	player[2] = add3({mul3({wishVelocity, addSpeed}), player[2]})
	
skipPlayerAccelerate:





camRot[1]=camRot[1] - gN({3})/rotateSpeedInv
camRot[2]=mn({mx({camRot[2] + gN({4})/rotateSpeedInv,0-verticalLookLimiter}),verticalLookLimiter})
--camRot[3]=camRot[3] + gN({1})/rotateSpeedInv

maxRollCorrectionCur = maxRollCorrection*deltaTime
camRot[3] = mn({mx({0, camRot[3]-maxRollCorrectionCur}), camRot[3]+maxRollCorrectionCur})



exit





playerHoldFunc:

gB2 = gB({2})
gB2==falseVar ~ skipgB2
gB2Old ~ skipgB2
	holdObject ~ dropObject
		junk = doRaycast({player[1][1],cameraRotationVector,holdRange})
		
		rayHit ~ doHoldObject
		1 ~ skipgB2
		doHoldObject:			
			holdMaxMass > bestObject[10] ~ skipgB2
				holdObject = {bestObject}[1]
	1 ~ skipgB2
	dropObject:
		holdObject = nilTable[1]
		holdVectorOld = nilTable[1]
skipgB2:
gB2Old = {gB2}[1]


holdObject ~ doCalcHoldObject
1 ~ skipCalcHoldObject
doCalcHoldObject:
	holdVector = add3({mul3({cameraRotationVector,holdDistance}),camPos})
	
	holdVectorOld ~ skipHoldVectorOldInit
		holdVectorOld = {holdVector}[1]
	skipHoldVectorOldInit:
	
	holdObject[1][1] = holdVectorOld
	holdObject[2] = mul3({sub3({holdVector,holdVectorOld}),1/deltaTime})
	holdVectorOld = {holdVector}[1]
	
skipCalcHoldObject:

exit




postTransformFunc:

portalOrangeQuaternion = portalOrange[4][1]
portalBlueQuaternion = multQuaternionByQuaternion({{0,0,1,0},portalBlue[4][1]})
portalBlueQuaternionInverse = {0-portalBlueQuaternion[1],portalBlueQuaternion[2],portalBlueQuaternion[3],portalBlueQuaternion[4]}

portalBlueToOrangeQuaternion = multQuaternionByQuaternion({portalBlueQuaternionInverse,portalOrangeQuaternion})
portalOrangeToBlueQuaternion = {portalBlueToOrangeQuaternion[1], 0-portalBlueToOrangeQuaternion[2], 0-portalBlueToOrangeQuaternion[3], 0-portalBlueToOrangeQuaternion[4]}

portalOrangeToBlueMatrix = quaternionToMatrix({portalOrangeToBlueQuaternion})
portalBlueToOrangeMatrix = quaternionToMatrix({portalBlueToOrangeQuaternion})




objectIndex = #objects
portalTeleportLoop:
	object = objects[objectIndex]
	object[17][2] = nilVar
	object[18][2] = nilVar
	i = 0
	
	object[10] > 0 ~ doPortalCollisionLoop
		1 ~ skipPortalCollisionLoop
	doPortalCollisionLoop:
		portalCollisionLoop:
			i = i+1
			
			i > 1 ~ chooseBluePortalCollision
				portalPrimary = {portalOrange}[1]
				portalSecondary = {portalBlue}[1]
				portalPrimarytoSecondaryQuaternion = {portalOrangeToBlueQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalOrangeToBlueMatrix}[1]
				portalSecondarytoPrimaryQuaternion = {portalBlueToOrangeQuaternion}[1]
				portalSecondarytoPrimaryMatrix = {portalBlueToOrangeMatrix}[1]
			1 ~ endPortalChoosingCollision
			chooseBluePortalCollision:
				portalPrimary = {portalBlue}[1]
				portalSecondary = {portalOrange}[1]
				portalPrimarytoSecondaryQuaternion = {portalBlueToOrangeQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalBlueToOrangeMatrix}[1]
				portalSecondarytoPrimaryQuaternion = {portalOrangeToBlueQuaternion}[1]
				portalSecondarytoPrimaryMatrix = {portalOrangeToBlueMatrix}[1]
			endPortalChoosingCollision:
			
			j = 0
			cr = #object[9]
			portalCollisionCheckLoop1:
				j = j + 1
				dist3({object[1][j],portalPrimary[1][1]}) > object[13][1][j]+portalPrimary[13][1][1] ~ skipPortalCollision
			cr > j ~ portalCollisionCheckLoop1
			
			dontSkipPortalCollision1:
				portalPrimaryPhysMesh1 = portalPrimary[9][1]
				portalPrimaryPhysMesh2 = portalPrimary[9][2]
				j = 0
				portalCollisionCheckLoop2:
					j = j + 1
					isColliding = gjkCollisionDetection({{portalPrimaryPhysMesh1[1],portalPrimaryPhysMesh1[2],portalPrimaryPhysMesh2[1],portalPrimaryPhysMesh2[2]},object[9][j]})
					isColliding ~ dontSkipPortalCollision2
				cr > j ~ portalCollisionCheckLoop2
				1 ~ skipPortalCollision
				dontSkipPortalCollision2:
					object[17][2] = portalPrimary[17][1]
					
					--object[18][2] ~ skipPortalCollision
					
					sideVal = dot3({sub3({object[1][1],portalPrimary[1][1]}), portalPrimary[8][1][1][9]})
					
					newPos = add3({multVectorByMatrix({sub3({object[1][1],portalPrimary[1][1]}),portalPrimarytoSecondaryMatrix}), portalSecondary[1][1]})
					newVel = multVectorByMatrix({sub3({object[2],mul3({object[12],deltaTime})}),portalPrimarytoSecondaryMatrix}) -- the "subtracting gravity" thing is needed to prevent the object from getting double friction on the ground. yes there is probably a better way
					newSpeed = dist3({object[2],{0,0,0}})
					object[11] > 0 ~ doTeleportRotate
						newQuat = object[4][1]
					1 ~ endTeleportRotate
					doTeleportRotate:
						newQuat = multQuaternionByQuaternion({object[4][1],portalPrimarytoSecondaryQuaternion})
					endTeleportRotate:
					newRotVel = multVectorByMatrix({object[5],portalPrimarytoSecondaryMatrix})
					
					maxThroughPortalSpeed > newSpeed ~ skipObjectSlowing
						newVel = mul3({newVel, maxThroughPortalSpeed/newSpeed})
					skipObjectSlowing:
						
					0 > sideVal ~ skipPortalTeleport
					holdObject == object ~ skipPortalTeleport 
						object[1][1] = newPos -- teleport object
						object[2] = newVel
						object[4][1] = newQuat
						object[5] = newRotVel
						
						object==player ~ doTeleportPlayerView
						1 ~ skipTeleportPlayerView
						cameraRotation = {camRot}[1]
						doTeleportPlayerView:
							junk = executeScript({cameraRotationToQuaternion}) -- todo: clean this up
							cameraRotationQuaternion = {cameraRotationQuaternion[1], 0-cameraRotationQuaternion[2], 0-cameraRotationQuaternion[3], 0-cameraRotationQuaternion[4]}
							cameraRotationQuaternion = multQuaternionByQuaternion({cameraRotationQuaternion,portalPrimarytoSecondaryQuaternion})
							cameraRotationQuaternion = {cameraRotationQuaternion[1], 0-cameraRotationQuaternion[2], 0-cameraRotationQuaternion[3], 0-cameraRotationQuaternion[4]}
							junk = executeScript({quaternionToCameraRotation})
						skipTeleportPlayerView:
						
						--junk = print(portalOrangeToBlueCamQuaternion)
						--junk = print(portalOrangeToBluePosQuaternion)
						
						--junk = print({"OK"})

					1 ~ skipPortalCollision:
					skipPortalTeleport:
						-- create a clone of the object on the opposite side
					
						index = object[14]
						conditions = {newPos,newVel,[4]=newQuat,[5]=newRotVel,[7]=object[10],[8]=object[11],[10]=object[20]}
						junk = executeScript({summonObjectFunc})
						newObject = objects[#objects]
						newObject[18][1] = nilVar
						newObject[18][2] = object
						newObject[18][3] = {portalPrimary[1][1],portalSecondary[1][1]}
						newObject[18][4] = {portalSecondarytoPrimaryQuaternion,portalSecondarytoPrimaryMatrix}
						junk = transformPhysPoints({newObject})
						object[18][2] = newObject
						object[18][3] = {portalSecondary[1][1],portalPrimary[1][1]}
						object[18][4] = {portalPrimarytoSecondaryQuaternion,portalPrimarytoSecondaryMatrix}
						
						newObject[17][2] = portalSecondary[17][1]
						
						
			skipPortalCollision:
		2>i ~ portalCollisionLoop
	skipPortalCollisionLoop:
	
	objectIndex = objectIndex - 1
objectIndex > 0 ~ portalTeleportLoop

camPos = player[1][1]




pegPoints = {} -- used to attach one point on an object to another point on another object


i = 0
pegPointsLen = #pegPoints
1 > pegPointsLen ~ pegPointLoopSkip
pegPointLoop:
	i = i + 1
	pegPoint = pegPoints[i]
	crPointLocal1 = pegPoint[4]
	crPointLocal2 = pegPoint[5]
	object1 = objects[pegPoint[1]]
	object2 = objects[pegPoint[2]]
	object3 = objects[pegPoint[3]]
	correctionDirection = pegPoint[6]
	correctionDirectionInverse = pegPoint[0]
	correctionDirection ~ correctionDirectionSkip1
		correctionDirectionInverse = 1
	correctionDirectionSkip1:
	
	correctionDirectionInverse ~ correctionDirectionSkip2
		correctionDirection = norm3({multVectorByMatrix({correctionDirection,object2[16][1]})})
	correctionDirectionSkip2:
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16][1]}),object1[1][1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16][1]}),object3[1][1]})
	
	totalDisplacement = sub3({crPoint1,crPoint2})
	correctionDirectionInverse ~ correctionDirectionSkip3
		totalDisplacement = sub3({totalDisplacement,mul3({correctionDirection,dot3({totalDisplacement,correctionDirection})})})
	correctionDirectionSkip3:
	
	totalDistance = dist3({totalDisplacement,{0,0,0}})
	0.0001 > totalDistance ~ skipPegMovement
		totalDisplacementNormalised = norm3({totalDisplacement})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalDisplacementNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalDisplacementNormalised}))
		junk = applyInstantMovement({object1,crPoint1,mul3({totalDisplacement,-1/movementFromPushing})})
		junk = applyInstantMovement({object2,crPoint1,mul3({totalDisplacement,1/movementFromPushing})})
		
		object1[16][1] = quaternionToMatrix({object1[4]})
		object2[16][1] = quaternionToMatrix({object2[4]})
	skipPegMovement:
	
	
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16][1]}),object1[1][1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16][1]}),object3[1][1]})
	
	velocity1 = add3({cross3({object1[5],sub3({crPoint1,object1[1][1]})}),object1[2]})
	velocity2 = add3({cross3({object2[5],sub3({crPoint2,object2[1][1]})}),object2[2]})
	totalVelocity = sub3({velocity1,velocity2})
	correctionDirectionInverse ~ correctionDirectionSkip4
		totalVelocity = sub3({totalVelocity,mul3({correctionDirection,dot3({totalVelocity,correctionDirection})})})
	correctionDirectionSkip4:
	
	totalSpeed = dist3({totalVelocity,{0,0,0}})
	0.0001 > totalSpeed ~ skipPegForce
		totalVelocityNormalised = norm3({totalVelocity})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalVelocityNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalVelocityNormalised}))
		junk = applyForce({object1,crPoint1,mul3({totalVelocity,-1/movementFromPushing})})
		junk = applyForce({object2,crPoint1,mul3({totalVelocity,1/movementFromPushing})})
	skipPegForce:
	
	--object1[16][1] = quaternionToMatrix({object1[4]}) -- not needed, previous section of code doesn't move objects
	--object2[16][1] = quaternionToMatrix({object2[4]})
pegPointsLen > i ~ pegPointLoop
pegPointLoopSkip:

i = 0
springsLen = #springs
1 > springsLen ~ springsLoopSkip
springsLoop:
	i = i + 1
	spring = springs[i]
	object1 = objects[spring[1]]
	object2 = objects[spring[2]]
	crPoint1 = add3({multVectorByMatrix({spring[3],object1[16][1]}),object1[1][1]})
	crPoint2 = add3({multVectorByMatrix({spring[4],object2[16][1]}),object2[1][1]})
	
	displacement = sub3({crPoint2,crPoint1})
	distance = dist3({displacement,{0,0,0}})
	displacementNormalised = mul3({displacement,1/distance})
	0.0001 > distance ~ skipSpringForce
		force = mul3({displacementNormalised,(spring[5]-distance)*spring[6]*deltaTime})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
		
		spring[8] ~ skipSpringInit
		spring[8] = distance
		skipSpringInit:
		
		force = mul3({displacementNormalised,(spring[8] - distance) * spring[7]})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
	skipSpringForce:
	
	spring[8] = distance
springsLen > i ~ springsLoop
springsLoopSkip:

exit





renderFunc:


viewPerformanceInfo = {}


portalsBoth = {portalOrange,portalBlue}

w_2 = 0-screenWidth2
h_2 = 0-screenHeight2
depth = screenWidth2/fovTan
viewBounding = {{w_2,screenHeight2,depth},{screenWidth2,screenHeight2,depth},{screenWidth2,h_2,depth},{w_2,h_2,depth}}
cameraRotation = {camRot}[1]
junk = executeScript({cameraRotationToQuaternion})
remainingRenderingPasses = {{camPos,cameraRotationQuaternion,viewBounding,{},1}}
allViews = {}

renderingLoop:
	renderingPass = remainingRenderingPasses[1]
	overallViewNumber = overallViewNumber + 1

	cameraPosition = renderingPass[1]
	cameraRotationQuaternion = renderingPass[2]
	

	--viewBounding = {{-90,-60},{100,-50},{100,50},{-100,50}}

	--viewBounding = {{0,-70},{100,-20},{50,70},{-50,70},{-100,-20}}
	viewBounding = renderingPass[3]

	viewBoundingLen = #viewBounding
	
	viewBoundingPlanes = renderingPass[4]
	
	itterLevel = renderingPass[5]
	
	
	
	i = 0
	viewBounding[viewBoundingLen+1] = viewBounding[1]
	viewBoundingConversionLoop:
		i = i+1
		point1 = viewBounding[i]
		point2 = viewBounding[i+1]
		planeNormal = norm3({crossPoints({point1,{0,0,0},point2})})
		viewBoundingPlanes[#viewBoundingPlanes+1] = {planeNormal,dot3({point1,planeNormal})}
	viewBoundingLen > i ~ viewBoundingConversionLoop
	viewBounding[viewBoundingLen+1] = nil
	
	
	
	
	cameraRotationMatrix = quaternionToMatrix({cameraRotationQuaternion})
	
	viewPerformanceInfoObjects = 0
	junk = renderView({1})
	viewPerformanceInfo[#viewPerformanceInfo+1] = viewPerformanceInfoObjects
	
	
	
	curView = {renderShapes,{}}
	curViewInfo = curView[2]
	allViews[#allViews+1] = curView
	
	2 > itterLevel ~ skipViewWriting
		oldViewInfo = renderingPass[6]
		oldView = oldViewInfo[1]
		oldViewIndex = oldViewInfo[2]
		oldView[oldViewIndex+2] = curView
	skipViewWriting:
	
	
	itterLevel > itterMax ~ skipAllPortalRendering
	
		cameraPositionOld = {cameraPosition}[1]
		cameraRotationQuaternionOld = {cameraRotationQuaternion}[1]
		viewBoundingOld = {viewBounding}[1]
		viewBoundingPlanesOld = {viewBoundingPlanes}[1]
		
		
		i = 0
		portalViewMathsLoop:
			i = i + 1
			
			
			i > 1 ~ chooseBluePortalRender
				portalPrimary = {portalOrange}[1]
				portalSecondary = {portalBlue}[1]
				portalSecondaryToPrimaryQuaternion = {portalBlueToOrangeQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalOrangeToBlueMatrix}[1]
			1 ~ endPortalChoosingRender
			chooseBluePortalRender:
				portalPrimary = {portalBlue}[1]
				portalSecondary = {portalOrange}[1]
				portalSecondaryToPrimaryQuaternion = {portalOrangeToBlueQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalBlueToOrangeMatrix}[1]
			endPortalChoosingRender:
			
			overallViewNumber > portalPrimary[19] ~ skipCurrentPortal
				
				portalMesh = portalPrimary[7][1]
				portalTris = portalPrimary[8][1]
				curTri = portalTris[1]
				portalPoint = portalMesh[curTri[1]]
				
				0 > dot3({curTri[9],portalPoint[3]}) ~ skipCurrentPortal -- skip portal if portal is facing away from player
				
					
					
					portalMeshLen = 8 --#portalMesh -- no longer uses entire mesh
					index1 = 0
					viewBounding = {}
					portalLoop:
						index1 = index1 + 1
						viewBounding[index1] = portalMesh[index1][4]
					portalMeshLen > index1 ~ portalLoop
					
					planeStart = 1
					viewBounding = intersectShapeWithPlanes({viewBounding,viewBoundingPlanes})
					
					viewBoundingLen = #viewBounding
					
					3 > viewBoundingLen ~ skipCurrentPortal -- need at least 3 points to form a shape with area#
					
						planeNormal = norm3({multVectorByMatrix({curTri[9],cameraRotationMatrix})})
						portalPlane = {planeNormal,dot3({portalPoint[4],planeNormal})}
						
						cameraRotationQuaternion = multQuaternionByQuaternion({portalSecondaryToPrimaryQuaternion, cameraRotationQuaternionOld})
						cameraPosition = add3({portalSecondary[1][1], multVectorByMatrix({sub3({cameraPositionOld,portalPrimary[1][1]}), portalPrimarytoSecondaryMatrix})})
						
						
						
						portalPrimaryMinDepth = curTri[8]
						j = 1
						findingMinPortalDepthLoop:
							j = j + 1
							portalPrimaryMinDepth = mn({portalPrimaryMinDepth,portalTris[j][3]})
						#portalTris>j ~ findingMinPortalDepthLoop
						
						curViewInfo[i] = portalPrimaryMinDepth
						
						remainingRenderingPasses[#remainingRenderingPasses+1] = {cameraPosition,cameraRotationQuaternion,viewBounding,{portalPlane},itterLevel+1,{curView,i}}
			skipCurrentPortal:
		2 > i ~ portalViewMathsLoop
	skipAllPortalRendering:
	
	junk = remove({remainingRenderingPasses,1})
#remainingRenderingPasses > 0 ~ renderingLoop


i = #allViews
viewProcessingLoop1:
	curView = allViews[i]
	curViewShapes = curView[1]
	curViewInfo = curView[2]
	
	moveCalls = {}
	
	j = 0
	viewProcessingLoop2:
		j = j+1
		viewToAdd = curView[j+2]
		viewToAdd ~ dontSkipViewAdding
		1~ skipViewAdding
		dontSkipViewAdding:
			viewToAdd = viewToAdd[1]
			--junk = move({curViewShapes,1,#curViewShapes,#viewToAdd+1})
			--junk = move({viewToAdd,1,#viewToAdd,1,curViewShapes})
			depthToFind = curViewInfo[j]
			
			index1 = 1
			index2 = #curViewShapes+1
			depthFindingLoop:
				index = index1 + flr({(index2-index1)/2})
				depthToFind > curViewShapes[index][3] ~ depthSearchLower
					index1 = index+1
				1 ~ depthSearchEnd
				depthSearchLower:
					index2 = index-0
				depthSearchEnd:
			index2>index1 ~ depthFindingLoop
			index = index1-0
			
			moveCalls[#moveCalls+1] = {index1,viewToAdd}
			
			--junk = move({viewToAdd,1,#viewToAdd,#curViewShapes+1,curViewShapes})
		skipViewAdding:
		
	2>j ~ viewProcessingLoop2
	
	1 > #moveCalls ~ skipMoveCalls
		2 > #moveCalls ~ skipMoveCallsSort
			moveCalls[1][1] > moveCalls[2][1] ~ skipMoveCallsSort
				junk = moveCalls[2]
				moveCalls[2] = moveCalls[1]
				moveCalls[1] = junk
		skipMoveCallsSort:
		
		j = 0
		moveCallsLoop:
			j = j+1
			index = moveCalls[j][1]
			viewToAdd = moveCalls[j][2]
			junk = move({curViewShapes,index,#curViewShapes,index+#viewToAdd})
			junk = move({viewToAdd,1,#viewToAdd,index,curViewShapes})
		#moveCalls > j ~ moveCallsLoop
	skipMoveCalls:
	
	i = i - 1
i > 0 ~ viewProcessingLoop1
--junk = print({})

renderShapesAll = allViews[1][1]

exit
	


cameraRotationToQuaternion:

a=cameraRotation[1]/-2
b=cameraRotation[2]/-2
c=cameraRotation[3]/-2

cr = cos({c})
sr = sin({c})
cp = cos({b})
sp = sin({b})
cy = cos({a})
sy = sin({a})


cameraRotationQuaternion = {}
cameraRotationQuaternion[1] = cr * cp * cy + sr * sp * sy
cameraRotationQuaternion[4] = sr * cp * cy - cr * sp * sy
cameraRotationQuaternion[2] = cr * sp * cy + sr * cp * sy
cameraRotationQuaternion[3] = cr * cp * sy - sr * sp * cy

exit

quaternionToCameraRotation:


qw = cameraRotationQuaternion[1]
qx = cameraRotationQuaternion[4] -- the yaw pitch and roll axis weren't the same, ok?
qy = cameraRotationQuaternion[2]
qz = cameraRotationQuaternion[3]

-- Roll (x-axis rotation)
roll = 0-(atan({2 * (qw * qx + qy * qz), 1 - (2 * (qx*qx + qy*qy))}))

-- Pitch (y-axis rotation)
pitch = 0-(asin({2 * (qw * qy - qz * qx)}))

-- Yaw (z-axis rotation)
yaw = 0-(atan({2 * (qw * qz + qx * qy), 1 - (2 * (qy*qy + qz*qz))}))

--junk = print({yaw,pitch,roll})
--junk = print(cameraRotation)
camRot = {yaw,pitch,roll}

exit





summonObjectFunc:

conditions ~ skipConditionWrite0
conditions = {}
skipConditionWrite0:

conditions[1] ~ skipConditionWrite1
conditions[1] = {0,0,0}
skipConditionWrite1:
conditions[2] ~ skipConditionWrite2
conditions[2] = {0,0,0}
skipConditionWrite2:
conditions[3] ~ skipConditionWrite3
conditions[3] = {0,0,0}
skipConditionWrite3:
conditions[4] ~ skipConditionWrite4
conditions[4] = {1,0,0,0}
skipConditionWrite4:
conditions[5] ~ skipConditionWrite5
conditions[5] = {0,0,0}
skipConditionWrite5:
conditions[6] ~ skipConditionWrite6
conditions[6] = {0,0,0}
skipConditionWrite6:
conditions[7] ~ skipConditionWrite7
conditions[7] = 1
skipConditionWrite7:
conditions[8] ~ skipConditionWrite8
conditions[8] = 1
skipConditionWrite8:
conditions[9] ~ skipConditionWrite9
conditions[9] = {0,0,0}
skipConditionWrite9:


sourceObjectInfo = M[1][index]
sourceObjectInfoLen = #sourceObjectInfo
newPointses = {}
newTrises = {}
newRenderDists = {}
newPhyses = {}
newPhysDists = {}
submeshInformation = {}
n = 1
newObjectCopyStuff:

	newPoints={}
	j=1
	ilocal = sourceObjectInfo[n]-1
	sourceObjectInfo[n] > sourceObjectInfo[n+1] ~ skipObjectCopyRenderPoints
	newObjectCopyRenderPoints:
		ilocal=ilocal+1
		cr=M[2][ilocal]
		newPoints[j]={{cr[1],cr[2],cr[3]}}
		j=j+1
	sourceObjectInfo[n+1] > ilocal ~ newObjectCopyRenderPoints
	skipObjectCopyRenderPoints:
	newPointses[#newPointses+1] = newPoints

	newTris={}
	j=1
	ilocal = sourceObjectInfo[n+2]-1
	sourceObjectInfo[n+2] > sourceObjectInfo[n+3] ~ skipObjectCopyRenderTris
	newObjectCopyRenderTris:
		ilocal=ilocal+1
		cr=M[3][ilocal]
		newTris[j]={cr[1],cr[2],cr[3],{cr[4],cr[5],cr[6],cr[7]},{[4]=cr[7]}}
		j=j+1
	sourceObjectInfo[n+3] > ilocal ~ newObjectCopyRenderTris
	skipObjectCopyRenderTris:
	newTrises[#newTrises+1] = newTris
	
	newRenderDists[#newRenderDists+1] = sourceObjectInfo[n+4]
	

	newPhys={}
	j=1
	ilocal = sourceObjectInfo[n+5]-1
	sourceObjectInfo[n+5] > sourceObjectInfo[n+6] ~ skipObjectCopyPhysPoints
	newObjectCopyPhysPoints2:
		ilocal=ilocal+1
		cr=M[2][ilocal]
		newPhys[j]={{cr[1],cr[2],cr[3]}}
		j=j+1
	sourceObjectInfo[n+6] > ilocal ~ newObjectCopyPhysPoints2
	skipObjectCopyPhysPoints:
	newPhyses[#newPhyses+1] = newPhys
	
	newPhysDists[#newPhysDists+1] = sourceObjectInfo[n+7]
	
	n=n+8
	
	submeshInformation[#submeshInformation+1] = {1,{0,0,0},{1,0,0,0}}
#sourceObjectInfo > n ~ newObjectCopyStuff
submeshInformation[#submeshInformation] = nilVar


conditions[10] ~ skipConditionWrite10
conditions[10] = submeshInformation
skipConditionWrite10:

newObject={$-- position, velocity, acceleration, orientation, rotation velocity, rotation acceleration, points, tris
	{conditions[1]},$ -- 1
	conditions[2],$ -- 2
	conditions[3],$ -- 3
	{conditions[4]},$ -- 4
	conditions[5],$ -- 5
	conditions[6],$ -- 6
	newPointses,$ -- 7
	newTrises,$ -- 8
	newPhyses,$ -- 9 collision mesh
	conditions[7],$ -- 10 ability to be moved, higher is easier to be moved
	conditions[8],$ -- 11 ability to be rotated, should really be a vec3
	conditions[9],$ -- 12 gravity
	{newPhysDists,newRenderDists},$ -- 13 max point dist from object's origin
	index,$ -- 14
	{},$ -- 15 previous collision points, not used
	{},$ -- 16 rotation matrix
	{},$ -- 17 don't collide with
	{1},$ -- 18 keep object
	0,$ -- 19 render itter number
	conditions[10], $ -- 20
}
objects[#objects+1]=newObject

exit









onDrawFunc:

text = screen["drawText"]
stCl = screen["setColor"]


junk = stCl({100,255,255})

junk = text({1,8,"obj"})

i = 0
viewPerformanceInfoLen = #viewPerformanceInfo
performanceMetricsLoop:
	i = i+1
	junk = text({1,i*6+8,viewPerformanceInfo[i]})
viewPerformanceInfoLen > i ~ performanceMetricsLoop

exit