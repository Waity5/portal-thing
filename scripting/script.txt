-- This is sscript, a scripting langauge made for StEVE (should pick a better name)
-- It is used to get around the 8k character limit

-- The syntax is lua-like but has its oddities due to the symplistic interpreter
-- e.g. using a table and a table.unpack on every function call






initFunc:


objects = {}

nilTable = {}
init = nilTable[1]

grav = {0,-600,0}

walkingSpeed = 150
walkingAccelerate = 10

camRot={0,0,0}

verticalLookLimiter = pi/2-0.001
rotateSpeed = 90
angleConvert=pi/180
fov=90*angleConvert

maxRollCorrection = 3
maxThroughPortalSpeed = 1000
itterMax = 3

holdMaxMass = 1/75
holdDistance = 72
holdRange = 100

playerYVelocityOld = 0

coefficientOfFriction = 1

index = "platform"
conditions = {{0,-8,0},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
index = "skybox"
conditions = {[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})

index = "portal_orange"
conditions = {{-64,56,256},[4]={0.5,0,0.5,0},[7]=0,[8]=0}
--conditions = {{0,0,200},[4]={0.5,-0.5,0,0},[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
portalOrange = objects[#objects]
--portalOrange[17] = objects[1]

index = "portal_blue"
conditions = {{64,56,256},[4]={0.5,0,-0.5,0},[7]=0,[8]=0}
--conditions = {{0,300,200},[4]=multQuaternionByQuaternion({norm4({{0.5,0.5,0,0}}),{0,0,1,0}}),[7]=0,[8]=0}
junk = executeScript({summonObjectFunc})
portalBlue = objects[#objects]
--portalBlue[17] = objects[1]

index = "player_bounding"
conditions = {{0,64,0},[7]=0.02,[8]=0,[9]=grav}
junk = executeScript({summonObjectFunc})
player = objects[#objects]

index1 = -3
index = "cube"
summonBoxes:
	conditions = {{160,20,index1*64},[7]=0.1,[8]=0.0001,[9]=grav}
	junk = executeScript({summonObjectFunc})
	index1 = index1+1
4>index1 ~ summonBoxes

--junk = summonObject({"hump",{{-10,0,0},[7]=0,[8]=0}})

springs = {} -- obj1, obj2, offset1, offset2, desired length, spring rate, dampen rate

exit





tickFunc:

screenScale = tan({fov/2})*screenWidth2

tickRate=62.5
deltaTime=1/tickRate


i = #objects
deleteObjectsLoop:
	objects[i][18][1] ~ skipDeleteObject
		junk = remove({objects,i})
	skipDeleteObject:
	i = i-1
i > 0 ~ deleteObjectsLoop



junk = executeScript({playerMovementFunc})

pushForce = 0
pushColour = {}
gB1 = gB({1})
gB1 ~ isGB1
gB3 = gB({3})
gB3 ~ isGB3
gB4 = gB({4})
gB4 ~ isGB4
	
	1 ~ endOfPush
isGB1:
	
	1 ~ endOfPush
isGB3:
	
	1 ~ endOfPush
isGB4:
	portalOrange[1]={-4,2.5,10}
	portalOrange[4]={0.75,-0.25,0,0}
	portalBlue[1]={0.75,1,11}
	
endOfPush:


a=camRot[1]
b=camRot[2]
c_a = cos({a})
s_a = sin({a})
c_b = cos({b})
s_b = sin({b})

--cameraRotationMatrix = {}
--cameraRotationMatrix[1] = {c_a*c_c - s_a*s_b*s_c , 0-c_b*s_c , c_a*s_b*s_c + c_c*s_a}
--cameraRotationMatrix[2] = {c_a*s_c + c_c*s_a*s_b , c_b*c_c , s_a*s_c - c_a*c_c*s_b}
--cameraRotationMatrix[3] = {0-c_b*s_a , s_b , c_a*c_b}


cameraRotationVector = {0-s_a*c_b,s_b,c_a*c_b}

junk = executeScript({playerHoldFunc})


exit





playerMovementFunc:

rotateSpeedCr=rotateSpeed*angleConvert/tickRate
rotateSpeedInv = 1/rotateSpeedCr

--gB31 = gB({31})
--gB31 ~ holdingSpace
--	camPos[1] = camPos[1] + (gN({1})*cos({camRot[1]}) - gN({2})*sin({camRot[1]})) / moveSpeedInv
--	camPos[3] = camPos[3] + (gN({1})*sin({camRot[1]}) + gN({2})*cos({camRot[1]})) / moveSpeedInv
--	maxPushForce = 0.5
--	otherPushColours = 50
--	1 ~ endCamMove
--holdingSpace:
--	camPos[2]=camPos[2] + gN({2}) / moveSpeedInv
--	maxPushForce = 2.5
--	otherPushColours = 0
--endCamMove:
camPos = player[1]

playerYVelocity = player[2][2]
playerGrounded = 1 > abs({playerYVelocity-playerYVelocityOld})
playerYVelocityOld = player[2][2]


wishVelocity = mul3({{gN({1})*cos({camRot[1]}) - (gN({2})*sin({camRot[1]})), 0, gN({1})*sin({camRot[1]}) + (gN({2})*cos({camRot[1]}))}, walkingSpeed})
wishSpeed = dist3({wishVelocity,{0,0,0}})
0.001 > wishSpeed ~ skipPlayerAccelerate
wishVelocity = norm3({wishVelocity})

wishSpeed = mn({wishSpeed,walkingSpeed})
playerGrounded ~ skipAirSpeedCap
	wishSpeed = mn({wishSpeed,30})
skipAirSpeedCap:


currentSpeed = dot3({player[2],wishVelocity})
addSpeed = wishSpeed - currentSpeed

0.001 > addSpeed ~ skipPlayerAccelerate
	accelSpeed = walkingAccelerate * wishSpeed * deltaTime
	
	addSpeed = mn({accelSpeed, addSpeed})
	player[2] = add3({mul3({wishVelocity, addSpeed}), player[2]})
	
skipPlayerAccelerate:

playerGrounded ~ doPlayerJump1
1 ~ skipPlayerJump
doPlayerJump1:
gB({31}) ~ doPlayerJump2
1 ~ skipPlayerJump
doPlayerJump2:
	player[2][2] = player[2][2] + 150
skipPlayerJump:



camRot[1]=camRot[1] - gN({3})/rotateSpeedInv
camRot[2]=clmp({camRot[2] + gN({4})/rotateSpeedInv,0-verticalLookLimiter,verticalLookLimiter})
--camRot[3]=camRot[3] + gN({1})/rotateSpeedInv

maxRollCorrectionCur = maxRollCorrection*deltaTime
camRot[3] = clmp({0, camRot[3]-maxRollCorrectionCur, camRot[3]+maxRollCorrectionCur})



exit





playerHoldFunc:

gB2 = gB({2})
gB2 ~ dontSkipgB2
1 ~ skipgB2
dontSkipgB2:
gB2Old ~ skipgB2
	holdObject ~ dropObject
		junk = doRaycast({player[1],cameraRotationVector,holdRange})
		
		rayHit ~ doHoldObject
		1 ~ skipgB2
		doHoldObject:			
			holdMaxMass > bestObject[10] ~ skipgB2
				holdObject = {bestObject}[1]
	1 ~ skipgB2
	dropObject:
		holdObject = nilTable[1]
		holdVectorOld = nilTable[1]
skipgB2:
gB2Old = {gB2}[1]


holdObject ~ doCalcHoldObject
1 ~ skipCalcHoldObject
doCalcHoldObject:
	holdVector = add3({mul3({cameraRotationVector,holdDistance}),camPos})
	
	holdVectorOld ~ skipHoldVectorOldInit
		holdVectorOld = {holdVector}[1]
	skipHoldVectorOldInit:
	
	holdObject[1] = holdVectorOld
	holdObject[2] = mul3({sub3({holdVector,holdVectorOld}),1/deltaTime})
	holdVectorOld = {holdVector}[1]
	
skipCalcHoldObject:

exit




postTransformFunc:

portalOrangeQuaternion = portalOrange[4]
portalBlueQuaternion = multQuaternionByQuaternion({{0,0,1,0},portalBlue[4]})
portalBlueQuaternionInverse = {0-portalBlueQuaternion[1],portalBlueQuaternion[2],portalBlueQuaternion[3],portalBlueQuaternion[4]}

portalBlueToOrangeQuaternion = multQuaternionByQuaternion({portalBlueQuaternionInverse,portalOrangeQuaternion})
portalOrangeToBlueQuaternion = {portalBlueToOrangeQuaternion[1], 0-portalBlueToOrangeQuaternion[2], 0-portalBlueToOrangeQuaternion[3], 0-portalBlueToOrangeQuaternion[4]}

portalOrangeToBlueMatrix = quaternionToMatrix({portalOrangeToBlueQuaternion})
portalBlueToOrangeMatrix = quaternionToMatrix({portalBlueToOrangeQuaternion})


objectIndex = #objects
portalTeleportLoop:
	object = objects[objectIndex]
	object[17] = nilVar
	i = 0
	
	object[10] > 0 ~ doPortalCollisionLoop
		1 ~ skipPortalCollisionLoop
	doPortalCollisionLoop:
		portalCollisionLoop:
			i = i+1
			
			i > 1 ~ chooseBluePortalCollision
				portalPrimary = {portalOrange}[1]
				portalSecondary = {portalBlue}[1]
				portalPrimarytoSecondaryQuaternion = {portalOrangeToBlueQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalOrangeToBlueMatrix}[1]
			1 ~ endPortalChoosingCollision
			chooseBluePortalCollision:
				portalPrimary = {portalBlue}[1]
				portalSecondary = {portalOrange}[1]
				portalPrimarytoSecondaryQuaternion = {portalBlueToOrangeQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalBlueToOrangeMatrix}[1]
			endPortalChoosingCollision:
			
			dist3({object[1],portalPrimary[1]}) > object[13]+portalPrimary[13] ~ skipPortalCollision
				portalPrimaryPhysMesh1 = portalPrimary[9][1]
				portalPrimaryPhysMesh2 = portalPrimary[9][2]
				isColliding = gjkCollisionDetection({{portalPrimaryPhysMesh1[1],portalPrimaryPhysMesh1[2],portalPrimaryPhysMesh1[3],portalPrimaryPhysMesh1[4],portalPrimaryPhysMesh2[1],portalPrimaryPhysMesh2[2],portalPrimaryPhysMesh2[3],portalPrimaryPhysMesh2[4]},object[9][1]})
				isColliding ~ dontSkipPortalCollision
				1 ~ skipPortalCollision
				dontSkipPortalCollision:
					object[17] = portalPrimary[17]
					sideVal = dot3({sub3({object[1],portalPrimary[1]}), portalPrimary[8][1][8]})
					
					newPos = add3({sub3({object[1],portalPrimary[1]}), portalSecondary[1]})
					newVel = multVectorByMatrix({object[2],portalPrimarytoSecondaryMatrix})
					newSpeed = dist3({object[2],{0,0,0}})
					object[11] > 0 ~ doTeleportRotate
						newQuat = object[4]
					1 ~ endTeleportRotate
					doTeleportRotate:
						newQuat = multQuaternionByQuaternion({object[4],portalPrimarytoSecondaryQuaternion})
					endTeleportRotate:
					
					maxThroughPortalSpeed > newSpeed ~ skipObjectSlowing
						newVel = mul3({newVel, maxThroughPortalSpeed/newSpeed})
					skipObjectSlowing:
						
					0 > sideVal ~ skipPortalTeleport
						object[1] = newPos
						object[2] = newVel
						
						
						cameraRotation = {camRot}[1]
						junk = executeScript({cameraRotationToQuaternion}) -- todo: clean this up
						cameraRotationQuaternion = {cameraRotationQuaternion[1], 0-cameraRotationQuaternion[2], 0-cameraRotationQuaternion[3], 0-cameraRotationQuaternion[4]}
						cameraRotationQuaternion = multQuaternionByQuaternion({cameraRotationQuaternion,portalPrimarytoSecondaryQuaternion})
						cameraRotationQuaternion = {cameraRotationQuaternion[1], 0-cameraRotationQuaternion[2], 0-cameraRotationQuaternion[3], 0-cameraRotationQuaternion[4]}
						junk = executeScript({quaternionToCameraRotation})
						
						--junk = print(portalOrangeToBlueCamQuaternion)
						--junk = print(portalOrangeToBluePosQuaternion)
						
						--junk = print({"OK"})

					1 ~ skipPortalCollision:
					skipPortalTeleport:
						
						index = object[14]
						conditions = {newPos,newVel,[4]=newQuat,[7]=object[10],[8]=object[11]}
						junk = executeScript({summonObjectFunc})
						newObject = objects[#objects]
						junk = transformPhysPoints({newObject})
						newObject[18][1] = nilVar
						
						
			skipPortalCollision:
		2>i ~ portalCollisionLoop
	skipPortalCollisionLoop:
	
	objectIndex = objectIndex - 1
objectIndex > 0 ~ portalTeleportLoop






pegPoints = {} -- used to attach one point on an object to another point on another object


i = 0
pegPointsLen = #pegPoints
1 > pegPointsLen ~ pegPointLoopSkip
pegPointLoop:
	i = i + 1
	pegPoint = pegPoints[i]
	crPointLocal1 = pegPoint[4]
	crPointLocal2 = pegPoint[5]
	object1 = objects[pegPoint[1]]
	object2 = objects[pegPoint[2]]
	object3 = objects[pegPoint[3]]
	correctionDirection = pegPoint[6]
	correctionDirectionInverse = pegPoint[0]
	correctionDirection ~ correctionDirectionSkip1
		correctionDirectionInverse = 1
	correctionDirectionSkip1:
	
	correctionDirectionInverse ~ correctionDirectionSkip2
		correctionDirection = norm3({multVectorByMatrix({correctionDirection,object2[16]})})
	correctionDirectionSkip2:
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	totalDisplacement = sub3({crPoint1,crPoint2})
	correctionDirectionInverse ~ correctionDirectionSkip3
		totalDisplacement = sub3({totalDisplacement,mul3({correctionDirection,dot3({totalDisplacement,correctionDirection})})})
	correctionDirectionSkip3:
	
	totalDistance = dist3({totalDisplacement,{0,0,0}})
	0.0001 > totalDistance ~ skipPegMovement
		totalDisplacementNormalised = norm3({totalDisplacement})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalDisplacementNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalDisplacementNormalised}))
		junk = applyInstantMovement({object1,crPoint1,mul3({totalDisplacement,-1/movementFromPushing})})
		junk = applyInstantMovement({object2,crPoint1,mul3({totalDisplacement,1/movementFromPushing})})
		
		object1[16] = quaternionToMatrix({object1[4]})
		object2[16] = quaternionToMatrix({object2[4]})
	skipPegMovement:
	
	
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	velocity1 = add3({cross3({object1[5],sub3({crPoint1,object1[1]})}),object1[2]})
	velocity2 = add3({cross3({object2[5],sub3({crPoint2,object2[1]})}),object2[2]})
	totalVelocity = sub3({velocity1,velocity2})
	correctionDirectionInverse ~ correctionDirectionSkip4
		totalVelocity = sub3({totalVelocity,mul3({correctionDirection,dot3({totalVelocity,correctionDirection})})})
	correctionDirectionSkip4:
	
	totalSpeed = dist3({totalVelocity,{0,0,0}})
	0.0001 > totalSpeed ~ skipPegForce
		totalVelocityNormalised = norm3({totalVelocity})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalVelocityNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalVelocityNormalised}))
		junk = applyForce({object1,crPoint1,mul3({totalVelocity,-1/movementFromPushing})})
		junk = applyForce({object2,crPoint1,mul3({totalVelocity,1/movementFromPushing})})
	skipPegForce:
	
	--object1[16] = quaternionToMatrix({object1[4]}) -- not needed, previous section of code doesn't move objects
	--object2[16] = quaternionToMatrix({object2[4]})
pegPointsLen > i ~ pegPointLoop
pegPointLoopSkip:

i = 0
springsLen = #springs
1 > springsLen ~ springsLoopSkip
springsLoop:
	i = i + 1
	spring = springs[i]
	object1 = objects[spring[1]]
	object2 = objects[spring[2]]
	crPoint1 = add3({multVectorByMatrix({spring[3],object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({spring[4],object2[16]}),object2[1]})
	
	displacement = sub3({crPoint2,crPoint1})
	distance = dist3({displacement,{0,0,0}})
	displacementNormalised = mul3({displacement,1/distance})
	0.0001 > distance ~ skipSpringForce
		force = mul3({displacementNormalised,(spring[5]-distance)*spring[6]*deltaTime})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
		
		spring[8] ~ skipSpringInit
		spring[8] = distance
		skipSpringInit:
		
		force = mul3({displacementNormalised,(spring[8] - distance) * spring[7]})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
	skipSpringForce:
	
	spring[8] = distance
springsLen > i ~ springsLoop
springsLoopSkip:

exit





renderFunc:




portalsBoth = {portalOrange,portalBlue}

w_2 = 0-screenWidth2
h_2 = 0-screenHeight2
viewBounding = {{w_2,h_2},{screenWidth2,h_2},{screenWidth2,screenHeight2},{w_2,screenHeight2}}
innerBounding = {w_2,screenWidth2,h_2,screenHeight2}
cameraRotation = {camRot}[1]
junk = executeScript({cameraRotationToQuaternion})
remainingRenderingPasses = {{camPos,cameraRotationQuaternion,viewBounding,innerBounding,innerBounding,{1,1,0,0}}}
allViews = {}

renderingLoop:
	renderingPass = remainingRenderingPasses[1]

	cameraPosition = renderingPass[1]
	cameraRotationQuaternion = renderingPass[2]
	

	--viewBounding = {{-90,-60},{100,-50},{100,50},{-100,50}}

	--viewBounding = {{0,-70},{100,-20},{50,70},{-50,70},{-100,-20}}
	viewBounding = renderingPass[3]

	viewBoundingLen = #viewBounding
	
	viewBoundingInnerBox = renderingPass[4]
	viewBoundingInnerBoxL = viewBoundingInnerBox[1]
	viewBoundingInnerBoxR = viewBoundingInnerBox[2]
	viewBoundingInnerBoxT = viewBoundingInnerBox[3]
	viewBoundingInnerBoxB = viewBoundingInnerBox[4]
	
	viewBoundingOuterBox = renderingPass[5]
	viewBoundingOuterBoxL = viewBoundingOuterBox[1]
	viewBoundingOuterBoxR = viewBoundingOuterBox[2]
	viewBoundingOuterBoxT = viewBoundingOuterBox[3]
	viewBoundingOuterBoxB = viewBoundingOuterBox[4]
	
	depthMods = renderingPass[6]
	itterLevel = depthMods[1]
	depthScale = depthMods[2]
	depthMinimum = depthMods[3]
	depthOffset = depthMods[4]
	
	
	
	
	cameraRotationMatrix = quaternionToMatrix({cameraRotationQuaternion})
	
	junk = renderView({1})
	
	
	curView = {renderShapes,{}}
	curViewInfo = curView[2]
	allViews[#allViews+1] = curView
	
	2 > itterLevel ~ skipViewWriting
		oldViewInfo = renderingPass[7]
		oldView = oldViewInfo[1]
		oldViewIndex = oldViewInfo[2]
		oldView[oldViewIndex+2] = curView
	skipViewWriting:
	
	
	itterLevel > itterMax ~ skipAllPortalRendering
		cameraPositionOld = {cameraPosition}[1]
		cameraRotationQuaternionOld = {cameraRotationQuaternion}[1]
		viewBoundingOld = {viewBounding}[1]
		depthScaleOld = depthScale-0
		depthMinimumOld = depthMinimum-0
		depthOffsetOld = depthOffset-0
		
		
		i = 0
		portalViewMathsLoop:
			i = i + 1
			
			
			i > 1 ~ chooseBluePortalRender
				portalPrimary = {portalOrange}[1]
				portalSecondary = {portalBlue}[1]
				portalSecondaryToPrimaryQuaternion = {portalBlueToOrangeQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalOrangeToBlueMatrix}[1]
			1 ~ endPortalChoosingRender
			chooseBluePortalRender:
				portalPrimary = {portalBlue}[1]
				portalSecondary = {portalOrange}[1]
				portalSecondaryToPrimaryQuaternion = {portalOrangeToBlueQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalBlueToOrangeMatrix}[1]
			endPortalChoosingRender:
			
			portalMesh = portalPrimary[7]
			portalTris = portalPrimary[8]
			curTri = portalTris[1]
			
			0 > dot3({curTri[8],portalMesh[curTri[1]][3]}) ~ skipCurrentPortal -- skip portal if portal is facing away from player
				
				portalMeshLen = 8 --#portalMesh -- no longer uses entire mesh
				index1 = 0
				index2 = 0
				viewBounding = {}
				portalLoop:
					index1 = index1 + 1
					
					1 > portalMesh[index1][6] ~ skipCurrentPortalPoint
						index2 = index2 + 1
						viewBounding[index2] = portalMesh[index1][5]
					skipCurrentPortalPoint:
					
				portalMeshLen > index1 ~ portalLoop
				
				viewBounding = intersectShapeWithShape({viewBounding,viewBoundingOld})
				
				viewBoundingLen = #viewBounding
				
				3 > viewBoundingLen ~ skipCurrentPortal -- need at least 3 points to form a shape with area
					viewBoundingInnerBoxL = 0
					viewBoundingInnerBoxR = 0
					viewBoundingInnerBoxT = 0
					viewBoundingInnerBoxB = 0
					innerBounding = {viewBoundingInnerBoxL,viewBoundingInnerBoxR,viewBoundingInnerBoxT,viewBoundingInnerBoxB}
					
					j = 0
					outerBoundingBoxLoop:
						j = j+1
						cr = viewBounding[j]
						crX = cr[1]
						crY = cr[2]
						viewBoundingOuterBoxL = mn({crX,viewBoundingOuterBoxL})
						viewBoundingOuterBoxR = mx({crX,viewBoundingOuterBoxR})
						viewBoundingOuterBoxT = mn({crY,viewBoundingOuterBoxT})
						viewBoundingOuterBoxB = mx({crY,viewBoundingOuterBoxB})
					viewBoundingLen>j ~ outerBoundingBoxLoop
					outerBounding = {viewBoundingOuterBoxL,viewBoundingOuterBoxR,viewBoundingOuterBoxT,viewBoundingOuterBoxB}
					
					
					cameraRotationQuaternion = multQuaternionByQuaternion({portalSecondaryToPrimaryQuaternion, cameraRotationQuaternionOld})
					cameraPosition = add3({portalSecondary[1], multVectorByMatrix({sub3({cameraPositionOld,portalPrimary[1]}), portalPrimarytoSecondaryMatrix})})
					
					--depthScale = depthScaleOld*0.0001
					--depthMinimum = dist3({portalPrimary[1],cameraPositionOld})
					--depthOffset = depthOffsetOld + ((depthMinimum-depthMinimumOld)*depthScaleOld)-(depthScaleOld/100)
					
					depthScale = 1
					depthMinimum = dist3({portalPrimary[1],cameraPositionOld})
					depthOffset = 0
					
					portalPrimaryMinDepth = curTri[7]
					j = 1
					findingMinPortalDepthLoop:
						j = j + 1
						portalPrimaryMinDepth = mn({portalPrimaryMinDepth,portalTris[j][7]})
					#portalTris>j ~ findingMinPortalDepthLoop
					
					curViewInfo[i] = portalPrimaryMinDepth
					
					remainingRenderingPasses[#remainingRenderingPasses+1] = {cameraPosition,cameraRotationQuaternion,viewBounding,innerBounding,outerBounding,{itterLevel+1,depthScale,depthMinimum,depthOffset},{curView,i}}
			skipCurrentPortal:
		2 > i ~ portalViewMathsLoop
	skipAllPortalRendering:
	
	junk = remove({remainingRenderingPasses,1})
#remainingRenderingPasses > 0 ~ renderingLoop


i = #allViews
viewProcessingLoop1:
	curView = allViews[i]
	curViewShapes = curView[1]
	curViewInfo = curView[2]
	
	j = 0
	viewProcessingLoop2:
		j = j+1
		viewToAdd = curView[j+2]
		viewToAdd ~ dontSkipViewAdding
		1~ skipViewAdding
		dontSkipViewAdding:
			viewToAdd = viewToAdd[1]
			--junk = move({curViewShapes,1,#curViewShapes,#viewToAdd+1})
			--junk = move({viewToAdd,1,#viewToAdd,1,curViewShapes})
			depthToFind = curViewInfo[j]
			
			index = 0
			depthFindingLoop:
				index = index + 1
				depthToFind > curViewShapes[index][5] ~ foundDepth
			#curViewShapes>index ~ depthFindingLoop
			1 ~ didntFoundDepth
			foundDepth:
			index = index-1
			didntFoundDepth:
			index = index+1
			--junk = print({index,depthToFind,curViewShapes[1][5],curViewShapes[2][5],curViewShapes[3][5],#curViewShapes,#viewToAdd})
			
			junk = move({curViewShapes,index,#curViewShapes,index+#viewToAdd})
			junk = move({viewToAdd,1,#viewToAdd,index,curViewShapes})
			
			--junk = move({viewToAdd,1,#viewToAdd,#curViewShapes+1,curViewShapes})
		skipViewAdding:
		
	2>j ~ viewProcessingLoop2
	
	i = i - 1
i > 0 ~ viewProcessingLoop1
--junk = print({})

renderShapesAll = allViews[1][1]

exit
	


cameraRotationToQuaternion:

a=cameraRotation[1]/-2
b=cameraRotation[2]/-2
c=cameraRotation[3]/-2

cr = cos({c})
sr = sin({c})
cp = cos({b})
sp = sin({b})
cy = cos({a})
sy = sin({a})


cameraRotationQuaternion = {}
cameraRotationQuaternion[1] = cr * cp * cy + sr * sp * sy
cameraRotationQuaternion[4] = sr * cp * cy - cr * sp * sy
cameraRotationQuaternion[2] = cr * sp * cy + sr * cp * sy
cameraRotationQuaternion[3] = cr * cp * sy - sr * sp * cy

exit

quaternionToCameraRotation:


qw = cameraRotationQuaternion[1]
qx = cameraRotationQuaternion[4] -- the yaw pitch and roll axis weren't the same, ok?
qy = cameraRotationQuaternion[2]
qz = cameraRotationQuaternion[3]

-- Roll (x-axis rotation)
roll = 0-(atan({2 * (qw * qx + qy * qz), 1 - (2 * (qx*qx + qy*qy))}))

-- Pitch (y-axis rotation)
pitch = 0-(asin({2 * (qw * qy - qz * qx)}))

-- Yaw (z-axis rotation)
yaw = 0-(atan({2 * (qw * qz + qx * qy), 1 - (2 * (qy*qy + qz*qz))}))

--junk = print({yaw,pitch,roll})
--junk = print(cameraRotation)
camRot = {yaw,pitch,roll}

exit





summonObjectFunc:

conditions ~ skipConditionWrite0
conditions = {}
skipConditionWrite0:

conditions[1] ~ skipConditionWrite1
conditions[1] = {0,0,0}
skipConditionWrite1:
conditions[2] ~ skipConditionWrite2
conditions[2] = {0,0,0}
skipConditionWrite2:
conditions[3] ~ skipConditionWrite3
conditions[3] = {0,0,0}
skipConditionWrite3:
conditions[4] ~ skipConditionWrite4
conditions[4] = {1,0,0,0}
skipConditionWrite4:
conditions[5] ~ skipConditionWrite5
conditions[5] = {0,0,0}
skipConditionWrite5:
conditions[6] ~ skipConditionWrite6
conditions[6] = {0,0,0}
skipConditionWrite6:
conditions[7] ~ skipConditionWrite7
conditions[7] = 1
skipConditionWrite7:
conditions[8] ~ skipConditionWrite8
conditions[8] = 1
skipConditionWrite8:
conditions[9] ~ skipConditionWrite9
conditions[9] = {0,0,0}
skipConditionWrite9:


sourceObjectInfo = M[1][index]
newPoints={}
j=1
ilocal = sourceObjectInfo[1]-1
newObjectCopyRenderPoints:
	ilocal=ilocal+1
	cr=M[2][ilocal]
	newPoints[j]={{cr[1],cr[2],cr[3]}}
	j=j+1
sourceObjectInfo[2] > ilocal ~ newObjectCopyRenderPoints

newTris={}
j=1
ilocal = sourceObjectInfo[3]-1
newObjectCopyRenderTris:
	ilocal=ilocal+1
	cr=M[3][ilocal]
	newTris[j]={cr[1],cr[2],cr[3],cr[4],cr[5],cr[6]}
	j=j+1
sourceObjectInfo[4] > ilocal ~ newObjectCopyRenderTris

newPhyses = {}
n = 6
newObjectCopyPhysPoints:
	newPhys={}
	j=1
	ilocal = sourceObjectInfo[n-1]-1
	newObjectCopyPhysPoints2:
		ilocal=ilocal+1
		cr=M[2][ilocal]
		newPhys[j]={{cr[1],cr[2],cr[3]}}
		j=j+1
	sourceObjectInfo[n] > ilocal ~ newObjectCopyPhysPoints2
	newPhyses[#newPhyses+1] = newPhys
	n=n+2
#sourceObjectInfo > n ~ newObjectCopyPhysPoints

newObject={$-- position, velocity, acceleration, orientation, rotation velocity, rotation acceleration, points, tris
	conditions[1],$ -- 1
	conditions[2],$ -- 2
	conditions[3],$ -- 3
	conditions[4],$ -- 4
	conditions[5],$ -- 5
	conditions[6],$ -- 6
	newPoints,$ -- 7
	newTris,$ -- 8
	newPhyses,$ -- 9 collision mesh
	conditions[7],$ -- 10 ability to be moved, higher is easier to be moved
	conditions[8],$ -- 11 ability to be rotated, should really be a vec3
	conditions[9],$ -- 12 gravity
	M[1][index][7],$ -- 13 max point dist from object's origin
	index,$ -- 14
	{},$ -- 15 previous collision points, not used
	{},$ -- 16 rotation matrix
	nilVar,$ -- 17 don't collide with
	{1},$ -- 18 keep object
}
objects[#objects+1]=newObject

exit