-- This is sscript, a scripting langauge made for StEVE (should pick a better name)
-- It is used to get around the 8k character limit

-- The syntax is lua-like but has its oddities due to the symplistic interpreter
-- e.g. using a table and a table.unpack on every function call






initFunc:

objects = {}

nilTable = {}
init = nilTable[1]

grav = {0,-600,0}

playerMoveForce = 5000

maxRollCorrection = 1
itterMax = 7

--junk = summonObject({"track1", {{0,-1,0},[7]=0,[8]=0}})
--junk = summonObject({"track2", {{0,-3,40},[7]=0,[8]=0}})
--junk = summonObject({"track3", {{5.5,-3,40},[7]=0,[8]=0}})
junk = summonObject({"platform", {{0,-8,0},[7]=0,[8]=0}})
junk = summonObject({"skybox", {[7]=0,[8]=0}})
--junk = summonObject({"blender_cube", {{0,1,11},[7]=0,[8]=0}})
--junk = summonObject({"cube", {{-4,1,7},[7]=0,[8]=0}})

junk = summonObject({"portal_orange", {{-64,56,320},[4]={0.5,0,0.5,0},[7]=0,[8]=0}})
--junk = summonObject({"portal_orange", {{-0.6,1,10},[4]={0.5,0,0.5,0},[7]=0,[8]=0}})
portalOrange = objects[#objects]
junk = summonObject({"portal_blue", {{64,56,320},[4]={0.53,0,-0.5,0},[7]=0,[8]=0}})
--junk = summonObject({"portal_blue", {{0,1,10.6},[4]={1,0,0,0},[7]=0,[8]=0}})
portalBlue = objects[#objects]
junk = summonObject({"player_bounding", {{0,64,0},[7]=0.02,[8]=0,[9]=grav}})
player = objects[#objects]

i = -3
summonBoxes:
	junk = summonObject({"cube",{{160,20,i*64},[7]=0.1,[8]=0.0001,[9]=grav}})
	i = i+1
4>i ~ summonBoxes

--junk = summonObject({"hump",{{-10,0,0},[7]=0,[8]=0}})

springs = {} -- obj1, obj2, offset1, offset2, desired length, spring rate, dampen rate

exit





tickFunc:




moveSpeedInv = 1/moveSpeed
rotateSpeedInv = 1/rotateSpeed

--gB31 = gB({31})
--gB31 ~ holdingSpace
--	camPos[1] = camPos[1] + (gN({1})*cos({camRot[1]}) - gN({2})*sin({camRot[1]})) / moveSpeedInv
--	camPos[3] = camPos[3] + (gN({1})*sin({camRot[1]}) + gN({2})*cos({camRot[1]})) / moveSpeedInv
--	maxPushForce = 0.5
--	otherPushColours = 50
--	1 ~ endCamMove
--holdingSpace:
--	camPos[2]=camPos[2] + gN({2}) / moveSpeedInv
--	maxPushForce = 2.5
--	otherPushColours = 0
--endCamMove:
camPos = player[1]

playerMoveForceCr = mul3({{gN({1})*cos({camRot[1]}) - (gN({2})*sin({camRot[1]})), 0, gN({1})*sin({camRot[1]}) + (gN({2})*cos({camRot[1]}))}, playerMoveForce*deltaTime})

junk = applyForce({player,player[1],playerMoveForceCr})

camRot[1]=camRot[1] - gN({3})/rotateSpeedInv
camRot[2]=camRot[2] + gN({4})/rotateSpeedInv
--camRot[3]=camRot[3] + gN({1})/rotateSpeedInv

maxRollCorrectionCur = maxRollCorrection*deltaTime
camRot[3] = clmp({0, camRot[3]-maxRollCorrectionCur, camRot[3]+maxRollCorrectionCur})


pushForce = 0
pushColour = {}
gB1 = gB({1})
gB1 ~ isGB1
gB3 = gB({3})
gB3 ~ isGB3
gB4 = gB({4})
gB4 ~ isGB4
	
	1 ~ endOfPush
isGB1:
	
	1 ~ endOfPush
isGB3:
	
	1 ~ endOfPush
isGB4:
	portalOrange[1]={-4,2.5,10}
	portalOrange[4]={0.75,-0.25,0,0}
	portalBlue[1]={0.75,1,11}
	
endOfPush:





a=camRot[1]
b=camRot[2]
c_a = cos({a})
s_a = sin({a})
c_b = cos({b})
s_b = sin({b})

--cameraRotationMatrix = {}
--cameraRotationMatrix[1] = {c_a*c_c - s_a*s_b*s_c , 0-c_b*s_c , c_a*s_b*s_c + c_c*s_a}
--cameraRotationMatrix[2] = {c_a*s_c + c_c*s_a*s_b , c_b*c_c , s_a*s_c - c_a*c_c*s_b}
--cameraRotationMatrix[3] = {0-c_b*s_a , s_b , c_a*c_b}


cameraRotationVector = {0-s_a*c_b,s_b,c_a*c_b}

exit







postTransformFunc:

portalOrangeQuaternion = portalOrange[4]
portalBlueQuaternion = multQuaternionByQuaternion({{0,0,1,0},portalBlue[4]})
portalBlueQuaternionInverse = {0-portalBlueQuaternion[1],portalBlueQuaternion[2],portalBlueQuaternion[3],portalBlueQuaternion[4]}

portalBlueToOrangeQuaternion = multQuaternionByQuaternion({portalBlueQuaternionInverse,portalOrangeQuaternion})
portalOrangeToBlueQuaternion = {portalBlueToOrangeQuaternion[1], 0-portalBlueToOrangeQuaternion[2], 0-portalBlueToOrangeQuaternion[3], 0-portalBlueToOrangeQuaternion[4]}

portalOrangeToBlueMatrix = quaternionToMatrix({portalOrangeToBlueQuaternion})
portalBlueToOrangeMatrix = quaternionToMatrix({portalBlueToOrangeQuaternion})






pegPoints = {} -- used to attach one point on an object to another point on another object


i = 0
pegPointsLen = #pegPoints
1 > pegPointsLen ~ pegPointLoopSkip
pegPointLoop:
	i = i + 1
	pegPoint = pegPoints[i]
	crPointLocal1 = pegPoint[4]
	crPointLocal2 = pegPoint[5]
	object1 = objects[pegPoint[1]]
	object2 = objects[pegPoint[2]]
	object3 = objects[pegPoint[3]]
	correctionDirection = pegPoint[6]
	correctionDirectionInverse = pegPoint[0]
	correctionDirection ~ correctionDirectionSkip1
		correctionDirectionInverse = 1
	correctionDirectionSkip1:
	
	correctionDirectionInverse ~ correctionDirectionSkip2
		correctionDirection = norm3({multVectorByMatrix({correctionDirection,object2[16]})})
	correctionDirectionSkip2:
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	totalDisplacement = sub3({crPoint1,crPoint2})
	correctionDirectionInverse ~ correctionDirectionSkip3
		totalDisplacement = sub3({totalDisplacement,mul3({correctionDirection,dot({totalDisplacement,correctionDirection})})})
	correctionDirectionSkip3:
	
	totalDistance = dist3({totalDisplacement,{0,0,0}})
	0.0001 > totalDistance ~ skipPegMovement
		totalDisplacementNormalised = norm3({totalDisplacement})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalDisplacementNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalDisplacementNormalised}))
		junk = applyInstantMovement({object1,crPoint1,mul3({totalDisplacement,-1/movementFromPushing})})
		junk = applyInstantMovement({object2,crPoint1,mul3({totalDisplacement,1/movementFromPushing})})
		
		object1[16] = quaternionToMatrix({object1[4]})
		object2[16] = quaternionToMatrix({object2[4]})
	skipPegMovement:
	
	
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	velocity1 = add3({cross({object1[5],sub3({crPoint1,object1[1]})}),object1[2]})
	velocity2 = add3({cross({object2[5],sub3({crPoint2,object2[1]})}),object2[2]})
	totalVelocity = sub3({velocity1,velocity2})
	correctionDirectionInverse ~ correctionDirectionSkip4
		totalVelocity = sub3({totalVelocity,mul3({correctionDirection,dot({totalVelocity,correctionDirection})})})
	correctionDirectionSkip4:
	
	totalSpeed = dist3({totalVelocity,{0,0,0}})
	0.0001 > totalSpeed ~ skipPegForce
		totalVelocityNormalised = norm3({totalVelocity})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalVelocityNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalVelocityNormalised}))
		junk = applyForce({object1,crPoint1,mul3({totalVelocity,-1/movementFromPushing})})
		junk = applyForce({object2,crPoint1,mul3({totalVelocity,1/movementFromPushing})})
	skipPegForce:
	
	--object1[16] = quaternionToMatrix({object1[4]}) -- not needed, previous section of code doesn't move objects
	--object2[16] = quaternionToMatrix({object2[4]})
pegPointsLen > i ~ pegPointLoop
pegPointLoopSkip:

i = 0
springsLen = #springs
1 > springsLen ~ springsLoopSkip
springsLoop:
	i = i + 1
	spring = springs[i]
	object1 = objects[spring[1]]
	object2 = objects[spring[2]]
	crPoint1 = add3({multVectorByMatrix({spring[3],object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({spring[4],object2[16]}),object2[1]})
	
	displacement = sub3({crPoint2,crPoint1})
	distance = dist3({displacement,{0,0,0}})
	displacementNormalised = mul3({displacement,1/distance})
	0.0001 > distance ~ skipSpringForce
		force = mul3({displacementNormalised,(spring[5]-distance)*spring[6]*deltaTime})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
		
		spring[8] ~ skipSpringInit
		spring[8] = distance
		skipSpringInit:
		
		force = mul3({displacementNormalised,(spring[8] - distance) * spring[7]})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
	skipSpringForce:
	
	spring[8] = distance
springsLen > i ~ springsLoop
springsLoopSkip:

exit





renderFunc:

-- temporarily put this here

i = 0
portalCollisionLoop:
	i = i+1
	
	i > 1 ~ chooseBluePortalCollision
		portalPrimary = {portalOrange}[1]
		portalSecondary = {portalBlue}[1]
		portalPrimarytoSecondaryQuaternion = {portalOrangeToBlueQuaternion}[1]
		portalPrimarytoSecondaryMatrix = {portalOrangeToBlueMatrix}[1]
	1 ~ endPortalChoosingCollision
	chooseBluePortalCollision:
		portalPrimary = {portalBlue}[1]
		portalSecondary = {portalOrange}[1]
		portalPrimarytoSecondaryQuaternion = {portalBlueToOrangeQuaternion}[1]
		portalPrimarytoSecondaryMatrix = {portalBlueToOrangeMatrix}[1]
	endPortalChoosingCollision:
	
	isColliding = gjkCollisionDetection({portalPrimary[7],player[9][1]})
	isColliding ~ dontSkipPortalCollision
	1 ~ skipPortalCollision
	dontSkipPortalCollision:
		sideVal = dot({sub3({player[1],portalPrimary[1]}), portalPrimary[8][1][8]})
		0 > sideVal ~ skipPortalTeleport
			player[1] = add3({sub3({player[1],portalPrimary[1]}), portalSecondary[1]})
			--camRot[1] = camRot[1] - (pi/2)
			player[2] = multVectorByMatrix({player[2],portalPrimarytoSecondaryMatrix})
			
			cameraRotation = {camRot}[1]
			junk = executeScript({cameraRotationToQuaternion}) -- todo: clean this up
			cameraRotationQuaternion = {cameraRotationQuaternion[1], 0-cameraRotationQuaternion[2], 0-cameraRotationQuaternion[3], 0-cameraRotationQuaternion[4]}
			cameraRotationQuaternion = multQuaternionByQuaternion({cameraRotationQuaternion,portalPrimarytoSecondaryQuaternion})
			cameraRotationQuaternion = {cameraRotationQuaternion[1], 0-cameraRotationQuaternion[2], 0-cameraRotationQuaternion[3], 0-cameraRotationQuaternion[4]}
			junk = executeScript({quaternionToCameraRotation})
			
			--junk = print(portalOrangeToBlueCamQuaternion)
			--junk = print(portalOrangeToBluePosQuaternion)
			
			--junk = print({"OK"})

			
		skipPortalTeleport:
	skipPortalCollision:
2>i ~ portalCollisionLoop





portalsBoth = {portalOrange,portalBlue}

w_2 = 0-w2
h_2 = 0-h2
viewBounding = {{w_2,h_2},{w2,h_2},{w2,h2},{w_2,h2}}
innerBounding = {w_2,w2,h_2,h2}
cameraRotation = {camRot}[1]
junk = executeScript({cameraRotationToQuaternion})
remainingRenderingPasses = {{camPos,cameraRotationQuaternion,viewBounding,innerBounding,innerBounding,{1,1,0,0}}}
allViews = {}

renderingLoop:
	renderingPass = remainingRenderingPasses[1]

	cameraPosition = renderingPass[1]
	cameraRotationQuaternion = renderingPass[2]
	

	--viewBounding = {{-90,-60},{100,-50},{100,50},{-100,50}}

	--viewBounding = {{0,-70},{100,-20},{50,70},{-50,70},{-100,-20}}
	viewBounding = renderingPass[3]

	viewBoundingLen = #viewBounding
	
	viewBoundingInnerBox = renderingPass[4]
	viewBoundingInnerBoxL = viewBoundingInnerBox[1]
	viewBoundingInnerBoxR = viewBoundingInnerBox[2]
	viewBoundingInnerBoxT = viewBoundingInnerBox[3]
	viewBoundingInnerBoxB = viewBoundingInnerBox[4]
	
	viewBoundingOuterBox = renderingPass[5]
	viewBoundingOuterBoxL = viewBoundingOuterBox[1]
	viewBoundingOuterBoxR = viewBoundingOuterBox[2]
	viewBoundingOuterBoxT = viewBoundingOuterBox[3]
	viewBoundingOuterBoxB = viewBoundingOuterBox[4]
	
	depthMods = renderingPass[6]
	itterLevel = depthMods[1]
	depthScale = depthMods[2]
	depthMinimum = depthMods[3]
	depthOffset = depthMods[4]
	
	
	
	
	cameraRotationMatrix = quaternionToMatrix({cameraRotationQuaternion})
	
	junk = renderView({1})
	
	
	curView = {renderShapes,{}}
	curViewInfo = curView[2]
	allViews[#allViews+1] = curView
	
	2 > itterLevel ~ skipViewWriting
		oldViewInfo = renderingPass[7]
		oldView = oldViewInfo[1]
		oldViewIndex = oldViewInfo[2]
		oldView[oldViewIndex+2] = curView
	skipViewWriting:
	
	
	itterLevel > itterMax ~ skipAllPortalRendering
		cameraPositionOld = {cameraPosition}[1]
		cameraRotationQuaternionOld = {cameraRotationQuaternion}[1]
		viewBoundingOld = {viewBounding}[1]
		depthScaleOld = depthScale-0
		depthMinimumOld = depthMinimum-0
		depthOffsetOld = depthOffset-0
		
		
		i = 0
		portalViewMathsLoop:
			i = i + 1
			
			
			i > 1 ~ chooseBluePortalRender
				portalPrimary = {portalOrange}[1]
				portalSecondary = {portalBlue}[1]
				portalSecondaryToPrimaryQuaternion = {portalBlueToOrangeQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalOrangeToBlueMatrix}[1]
			1 ~ endPortalChoosingRender
			chooseBluePortalRender:
				portalPrimary = {portalBlue}[1]
				portalSecondary = {portalOrange}[1]
				portalSecondaryToPrimaryQuaternion = {portalOrangeToBlueQuaternion}[1]
				portalPrimarytoSecondaryMatrix = {portalBlueToOrangeMatrix}[1]
			endPortalChoosingRender:
			
			portalMesh = portalPrimary[7]
			portalTris = portalPrimary[8]
			curTri = portalTris[1]
			
			0 > dot({curTri[8],portalMesh[curTri[1]][3]}) ~ skipCurrentPortal -- skip portal if portal is facing away from player
				
				portalMeshLen = 8 --#portalMesh -- no longer uses entire mesh
				index1 = 0
				index2 = 0
				viewBounding = {}
				portalLoop:
					index1 = index1 + 1
					
					1 > portalMesh[index1][6] ~ skipCurrentPortalPoint
						index2 = index2 + 1
						viewBounding[index2] = portalMesh[index1][5]
					skipCurrentPortalPoint:
					
				portalMeshLen > index1 ~ portalLoop
				
				viewBounding = intersectShapeWithShape({viewBounding,viewBoundingOld})
				
				viewBoundingLen = #viewBounding
				
				3 > viewBoundingLen ~ skipCurrentPortal -- need at least 3 points to form a shape with area
					viewBoundingInnerBoxL = 0
					viewBoundingInnerBoxR = 0
					viewBoundingInnerBoxT = 0
					viewBoundingInnerBoxB = 0
					innerBounding = {viewBoundingInnerBoxL,viewBoundingInnerBoxR,viewBoundingInnerBoxT,viewBoundingInnerBoxB}
					
					j = 0
					outerBoundingBoxLoop:
						j = j+1
						cr = viewBounding[j]
						crX = cr[1]
						crY = cr[2]
						viewBoundingOuterBoxL = mn({crX,viewBoundingOuterBoxL})
						viewBoundingOuterBoxR = mx({crX,viewBoundingOuterBoxR})
						viewBoundingOuterBoxT = mn({crY,viewBoundingOuterBoxT})
						viewBoundingOuterBoxB = mx({crY,viewBoundingOuterBoxB})
					viewBoundingLen>j ~ outerBoundingBoxLoop
					outerBounding = {viewBoundingOuterBoxL,viewBoundingOuterBoxR,viewBoundingOuterBoxT,viewBoundingOuterBoxB}
					
					
					cameraRotationQuaternion = multQuaternionByQuaternion({portalSecondaryToPrimaryQuaternion, cameraRotationQuaternionOld})
					cameraPosition = add3({portalSecondary[1], multVectorByMatrix({sub3({cameraPositionOld,portalPrimary[1]}), portalPrimarytoSecondaryMatrix})})
					
					--depthScale = depthScaleOld*0.0001
					--depthMinimum = dist3({portalPrimary[1],cameraPositionOld})
					--depthOffset = depthOffsetOld + ((depthMinimum-depthMinimumOld)*depthScaleOld)-(depthScaleOld/100)
					
					depthScale = 1
					depthMinimum = dist3({portalPrimary[1],cameraPositionOld})
					depthOffset = 0
					
					portalPrimaryMinDepth = curTri[7]
					j = 1
					findingMinPortalDepthLoop:
						j = j + 1
						portalPrimaryMinDepth = mn({portalPrimaryMinDepth,portalTris[j][7]})
					#portalTris>j ~ findingMinPortalDepthLoop
					
					curViewInfo[i] = portalPrimaryMinDepth
					
					remainingRenderingPasses[#remainingRenderingPasses+1] = {cameraPosition,cameraRotationQuaternion,viewBounding,innerBounding,outerBounding,{itterLevel+1,depthScale,depthMinimum,depthOffset},{curView,i}}
			skipCurrentPortal:
		2 > i ~ portalViewMathsLoop
	skipAllPortalRendering:
	
	junk = remove({remainingRenderingPasses,1})
#remainingRenderingPasses > 0 ~ renderingLoop


i = #allViews
viewProcessingLoop1:
	curView = allViews[i]
	curViewShapes = curView[1]
	curViewInfo = curView[2]
	
	j = 0
	viewProcessingLoop2:
		j = j+1
		viewToAdd = curView[j+2]
		viewToAdd ~ dontSkipViewAdding
		1~ skipViewAdding
		dontSkipViewAdding:
			viewToAdd = viewToAdd[1]
			--junk = move({curViewShapes,1,#curViewShapes,#viewToAdd+1})
			--junk = move({viewToAdd,1,#viewToAdd,1,curViewShapes})
			depthToFind = curViewInfo[j]
			
			index = 0
			depthFindingLoop:
				index = index + 1
				depthToFind > curViewShapes[index][5] ~ foundDepth
			#curViewShapes>index ~ depthFindingLoop
			1 ~ didntFoundDepth
			foundDepth:
			index = index-1
			didntFoundDepth:
			index = index+1
			--junk = print({index,depthToFind,curViewShapes[1][5],curViewShapes[2][5],curViewShapes[3][5],#curViewShapes,#viewToAdd})
			
			junk = move({curViewShapes,index,#curViewShapes,index+#viewToAdd})
			junk = move({viewToAdd,1,#viewToAdd,index,curViewShapes})
			
			--junk = move({viewToAdd,1,#viewToAdd,#curViewShapes+1,curViewShapes})
		skipViewAdding:
		
	2>j ~ viewProcessingLoop2
	
	i = i - 1
i > 0 ~ viewProcessingLoop1
--junk = print({})

renderShapesAll = allViews[1][1]

exit
	


cameraRotationToQuaternion:

a=cameraRotation[1]/-2
b=cameraRotation[2]/-2
c=cameraRotation[3]/-2

cr = cos({c})
sr = sin({c})
cp = cos({b})
sp = sin({b})
cy = cos({a})
sy = sin({a})


cameraRotationQuaternion = {}
cameraRotationQuaternion[1] = cr * cp * cy + sr * sp * sy
cameraRotationQuaternion[4] = sr * cp * cy - cr * sp * sy
cameraRotationQuaternion[2] = cr * sp * cy + sr * cp * sy
cameraRotationQuaternion[3] = cr * cp * sy - sr * sp * cy

exit

quaternionToCameraRotation:


qw = cameraRotationQuaternion[1]
qx = cameraRotationQuaternion[4] -- the yaw pitch and roll axis weren't the same, ok?
qy = cameraRotationQuaternion[2]
qz = cameraRotationQuaternion[3]

-- Roll (x-axis rotation)
roll = 0-(atan({2 * (qw * qx + qy * qz), 1 - (2 * (qx*qx + qy*qy))}))

-- Pitch (y-axis rotation)
pitch = 0-(asin({2 * (qw * qy - qz * qx)}))

-- Yaw (z-axis rotation)
yaw = 0-(atan({2 * (qw * qz + qx * qy), 1 - (2 * (qy*qy + qz*qz))}))

--junk = print({yaw,pitch,roll})
--junk = print(cameraRotation)
camRot = {yaw,pitch,roll}

exit