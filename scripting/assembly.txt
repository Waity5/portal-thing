initFunc:

objects = {}

init = objects[1]

grav = {0,-9.81,0}

playerMoveForce = 10


--junk = summonObject({"track1", {{0,-1,0},[7]=0,[8]=0}})
--junk = summonObject({"track2", {{0,-3,40},[7]=0,[8]=0}})
--junk = summonObject({"track3", {{5.5,-3,40},[7]=0,[8]=0}})
junk = summonObject({"widest_cube", {{0,-1,0},[7]=0,[8]=0}})
junk = summonObject({"skybox", {[7]=0,[8]=0}})
--junk = summonObject({"blender_cube", {{0,1,11},[7]=0,[8]=0}})
--junk = summonObject({"blender_cube", {{-4,1,7},[7]=0,[8]=0}})

junk = summonObject({"portal_orange", {{0,1,10},[4]={0.5,0,0.5,0},[7]=0,[8]=0}})
portalOrange = objects[#objects]
junk = summonObject({"portal_blue", {{0,2,7},[4]={0.75,0.25,0,0},[7]=0,[8]=0}})
portalBlue = objects[#objects]
junk = summonObject({"player_bounding", {{0,3,0},[7]=1,[8]=0,[9]=grav}})
player = objects[#objects]

i = -3
summonBoxes:
	junk = summonObject({"blender_cube",{{10,1,i*5},[7]=1,[8]=1,[9]=grav}})
	i = i+1
4>i ~ summonBoxes

junk = summonObject({"hump",{{-10,0,0},[7]=0,[8]=0}})

springs = {} -- obj1, obj2, offset1, offset2, desired length, spring rate, dampen rate

exit





tickFunc:




moveSpeedInv = 1/moveSpeed
rotateSpeedInv = 1/rotateSpeed

--gB31 = gB({31})
--gB31 ~ holdingSpace
--	camPos[1] = camPos[1] + (gN({1})*cos({camRot[1]}) - gN({2})*sin({camRot[1]})) / moveSpeedInv
--	camPos[3] = camPos[3] + (gN({1})*sin({camRot[1]}) + gN({2})*cos({camRot[1]})) / moveSpeedInv
--	maxPushForce = 0.5
--	otherPushColours = 50
--	1 ~ endCamMove
--holdingSpace:
--	camPos[2]=camPos[2] + gN({2}) / moveSpeedInv
--	maxPushForce = 2.5
--	otherPushColours = 0
--endCamMove:
camPos = player[1]

playerMoveForceCr = mul3({{gN({1})*cos({camRot[1]}) - (gN({2})*sin({camRot[1]})), 0, gN({1})*sin({camRot[1]}) + (gN({2})*cos({camRot[1]}))}, playerMoveForce*deltaTime})

junk = applyForce({player,player[1],playerMoveForceCr})

camRot[1]=camRot[1] - gN({3})/rotateSpeedInv
camRot[2]=camRot[2] + gN({4})/rotateSpeedInv

pushForce = 0
pushColour = {}
gB1 = gB({1})
gB1 ~ isGB1
gB3 = gB({3})
gB3 ~ isGB3
	pushColour[1] = 255
	pushColour[2] = 255
	pushColour[3] = 255
	1 ~ endOfPush
isGB1:
	pushForce = 0 - maxPushForce
	pushColour[1] = otherPushColours
	pushColour[2] = otherPushColours
	pushColour[3] = 255
	1 ~ endOfPush
isGB3:
	pushForce = maxPushForce - 0
	pushColour[1] = 255
	pushColour[2] = otherPushColours
	pushColour[3] = otherPushColours
endOfPush:




a=camRot[1]
b=camRot[2]
c_a = cos({a})
s_a = sin({a})
c_b = cos({b})
s_b = sin({b})

--cameraRotationMatrix = {}
--cameraRotationMatrix[1] = {c_a*c_c - s_a*s_b*s_c , 0-c_b*s_c , c_a*s_b*s_c + c_c*s_a}
--cameraRotationMatrix[2] = {c_a*s_c + c_c*s_a*s_b , c_b*c_c , s_a*s_c - c_a*c_c*s_b}
--cameraRotationMatrix[3] = {0-c_b*s_a , s_b , c_a*c_b}


cameraRotationVector = {0-s_a*c_b,s_b,c_a*c_b}

exit







postTransformFunc:

portalOrangeQuaternion = portalOrange[4]
portalOrangeQuaternionInverse = {0-portalOrangeQuaternion[1],portalOrangeQuaternion[2],portalOrangeQuaternion[3],portalOrangeQuaternion[4]}
portalBlueQuaternion = multQuaternionByQuaternion({{0,0,1,0},portalBlue[4]})
portalBlueQuaternionInverse = {0-portalBlueQuaternion[1],portalBlueQuaternion[2],portalBlueQuaternion[3],portalBlueQuaternion[4]}

--cameraRotationQuaternion = multQuaternionByQuaternion({multQuaternionByQuaternion({portalBlueQuaternionInverse,portalOrangeQuaternion}), cameraRotationQuaternion})

portalBlueToOrangeCamQuaternion = multQuaternionByQuaternion({portalBlueQuaternionInverse,portalOrangeQuaternion})
portalOrangeToBluePosQuaternion = multQuaternionByQuaternion({portalOrangeQuaternionInverse,portalBlueQuaternion})
portalOrangeToBlueCamQuaternion = {portalBlueToOrangeCamQuaternion[1], 0-portalBlueToOrangeCamQuaternion[2], 0-portalBlueToOrangeCamQuaternion[3], 0-portalBlueToOrangeCamQuaternion[4]}
portalBlueToOrangePosQuaternion = {portalOrangeToBluePosQuaternion[1], 0-portalOrangeToBluePosQuaternion[2], 0-portalOrangeToBluePosQuaternion[3], 0-portalOrangeToBluePosQuaternion[4]}



--portalPrimaryQuaternion = portalPrimary[4]
--portalPrimaryQuaternionInverse = {0-portalPrimaryQuaternion[1],portalPrimaryQuaternion[2],portalPrimaryQuaternion[3],portalPrimaryQuaternion[4]}
--portalSecondaryQuaternion = multQuaternionByQuaternion({{0,0,1,0},portalSecondary[4]})
--portalSecondaryQuaternionInverse = {0-portalSecondaryQuaternion[1],portalSecondaryQuaternion[2],portalSecondaryQuaternion[3],portalSecondaryQuaternion[4]}
--cameraRotationQuaternion = multQuaternionByQuaternion({multQuaternionByQuaternion({portalSecondaryQuaternionInverse,portalPrimaryQuaternion}), cameraRotationQuaternion})
--
--cameraPosition = add3({portalSecondary[1], multVectorByMatrix({sub3({camPos,portalPrimary[1]}), quaternionToMatrix({multQuaternionByQuaternion({portalPrimaryQuaternionInverse,portalSecondaryQuaternion})})})})






pegPoints = {}


i = 0
pegPointsLen = #pegPoints
1 > pegPointsLen ~ pegPointLoopSkip
pegPointLoop:
	i = i + 1
	pegPoint = pegPoints[i]
	crPointLocal1 = pegPoint[4]
	crPointLocal2 = pegPoint[5]
	object1 = objects[pegPoint[1]]
	object2 = objects[pegPoint[2]]
	object3 = objects[pegPoint[3]]
	correctionDirection = pegPoint[6]
	correctionDirectionInverse = pegPoint[0]
	correctionDirection ~ correctionDirectionSkip1
		correctionDirectionInverse = 1
	correctionDirectionSkip1:
	
	correctionDirectionInverse ~ correctionDirectionSkip2
		correctionDirection = norm3({multVectorByMatrix({correctionDirection,object2[16]})})
	correctionDirectionSkip2:
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	totalDisplacement = sub3({crPoint1,crPoint2})
	correctionDirectionInverse ~ correctionDirectionSkip3
		totalDisplacement = sub3({totalDisplacement,mul3({correctionDirection,dot({totalDisplacement,correctionDirection})})})
	correctionDirectionSkip3:
	
	totalDistance = dist3({totalDisplacement,{0,0,0}})
	0.0001 > totalDistance ~ skipPegMovement
		totalDisplacementNormalised = norm3({totalDisplacement})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalDisplacementNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalDisplacementNormalised}))
		junk = applyInstantMovement({object1,crPoint1,mul3({totalDisplacement,-1/movementFromPushing})})
		junk = applyInstantMovement({object2,crPoint1,mul3({totalDisplacement,1/movementFromPushing})})
		
		object1[16] = quaternionToMatrix({object1[4]})
		object2[16] = quaternionToMatrix({object2[4]})
	skipPegMovement:
	
	
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	velocity1 = add3({cross({object1[5],sub3({crPoint1,object1[1]})}),object1[2]})
	velocity2 = add3({cross({object2[5],sub3({crPoint2,object2[1]})}),object2[2]})
	totalVelocity = sub3({velocity1,velocity2})
	correctionDirectionInverse ~ correctionDirectionSkip4
		totalVelocity = sub3({totalVelocity,mul3({correctionDirection,dot({totalVelocity,correctionDirection})})})
	correctionDirectionSkip4:
	
	totalSpeed = dist3({totalVelocity,{0,0,0}})
	0.0001 > totalSpeed ~ skipPegForce
		totalVelocityNormalised = norm3({totalVelocity})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalVelocityNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalVelocityNormalised}))
		junk = applyForce({object1,crPoint1,mul3({totalVelocity,-1/movementFromPushing})})
		junk = applyForce({object2,crPoint1,mul3({totalVelocity,1/movementFromPushing})})
	skipPegForce:
	
	--object1[16] = quaternionToMatrix({object1[4]}) -- not needed, previous section of code doesn't move objects
	--object2[16] = quaternionToMatrix({object2[4]})
pegPointsLen > i ~ pegPointLoop
pegPointLoopSkip:

i = 0
springsLen = #springs
1 > springsLen ~ springsLoopSkip
springsLoop:
	i = i + 1
	spring = springs[i]
	object1 = objects[spring[1]]
	object2 = objects[spring[2]]
	crPoint1 = add3({multVectorByMatrix({spring[3],object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({spring[4],object2[16]}),object2[1]})
	
	displacement = sub3({crPoint2,crPoint1})
	distance = dist3({displacement,{0,0,0}})
	displacementNormalised = mul3({displacement,1/distance})
	0.0001 > distance ~ skipSpringForce
		force = mul3({displacementNormalised,(spring[5]-distance)*spring[6]*deltaTime})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
		
		spring[8] ~ skipSpringInit
		spring[8] = distance
		skipSpringInit:
		
		force = mul3({displacementNormalised,(spring[8] - distance) * spring[7]})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
	skipSpringForce:
	
	spring[8] = distance
springsLen > i ~ springsLoop
springsLoopSkip:

exit





renderFunc:

-- temporarily put this here

isColliding = gjkCollisionDetection({portalOrange[7],player[9]})
isColliding ~ dontSkipOrangeCollision
1 ~ skipOrangeCollision
dontSkipOrangeCollision:
	sideVal = dot({sub3({player[1],portalOrange[1]}), portalOrange[8][1][8]})
	0 > sideVal ~ skipOrangeTeleport
		player[1] = add3({sub3({player[1],portalOrange[1]}), portalBlue[1]})
		camRot[1] = camRot[1] - (pi/2)
		
	skipOrangeTeleport:
skipOrangeCollision:




renderingPassGlobal = 0
renderingLoop:
	renderingPassGlobal = renderingPassGlobal + 1
	
	renderingPassGlobal > 2 ~ skipPortalAreaMaths
	2 > renderingPassGlobal ~ skipPortalAreaMaths
		portalsToAreaMath = {portalOrange,portalBlue}
		portalAreas = {}
		i = 0
		skipPortalAreaMathsLoop:
			i = i + 1
			viewBounding = {}
			portalMesh = portalsToAreaMath[i][7]
			portalMeshLen = 8 --#portalMesh -- no longer uses entire mesh
			index1 = 0
			index2 = 0
			portalLoop:
				index1 = index1 + 1
				
				1 > portalMesh[index1][6] ~ skipCurrentPortalPoint
					index2 = index2 + 1
					viewBounding[index2] = portalMesh[index1][5]
				skipCurrentPortalPoint:
				
			portalMeshLen > index1 ~ portalLoop
			
			portalAreas[i] = viewBounding
		2 > i ~ skipPortalAreaMathsLoop
	skipPortalAreaMaths:

	renderingPassGlobal > 1 ~ portalViewRendering
		cameraPosition = {camPos}[1]
		cameraRotation = {camRot}[1]
		junk = executeScript({cameraRotationToQuaternion})

		--viewBounding = {{-90,-60},{100,-50},{100,50},{-100,50}}

		--viewBounding = {{0,-70},{100,-20},{50,70},{-50,70},{-100,-20}}
		viewBounding = {{-144,-80},{144,-80},{144,80},{-144,80}}

		viewBoundingLen = #viewBounding

		viewBoundingInnerBoxL = -144
		viewBoundingInnerBoxR = 144
		viewBoundingInnerBoxT = -80
		viewBoundingInnerBoxB = 80
		
		depthScale = 1
		depthMinimum = 0
		depthOffset = 0
		
	1 ~ endViewRenderingMaths
	portalViewRendering:
	
		renderingPassGlobal > 2 ~ chooseBluePortal
			portalPrimary = {portalOrange}[1]
			portalSecondary = {portalBlue}[1]
			portalSecondaryToPrimaryCamQuaternion = {portalBlueToOrangeCamQuaternion}[1]
			portalPrimarytoSecondaryPosQuaternion = {portalOrangeToBluePosQuaternion}[1]
		1 ~ endPortalChoosing
		chooseBluePortal:
			portalPrimary = {portalBlue}[1]
			portalSecondary = {portalOrange}[1]
			portalSecondaryToPrimaryCamQuaternion = {portalOrangeToBlueCamQuaternion}[1]
			portalPrimarytoSecondaryPosQuaternion = {portalBlueToOrangePosQuaternion}[1]
		endPortalChoosing:
			
		
		viewBounding = portalAreas[renderingPassGlobal-1]
		
		
		cameraRotation = {camRot}[1]
		
		junk = executeScript({cameraRotationToQuaternion})
		
		
		cameraRotationQuaternion = multQuaternionByQuaternion({portalSecondaryToPrimaryCamQuaternion, cameraRotationQuaternion})
		cameraPosition = add3({portalSecondary[1], multVectorByMatrix({sub3({camPos,portalPrimary[1]}), quaternionToMatrix({portalPrimarytoSecondaryPosQuaternion})})})
		

		--viewBounding = {{-90,-60},{100,-50},{100,50},{-100,50}}

		--viewBounding = {{0,-70},{100,-20},{50,70},{-50,70},{-100,-20}}
		--viewBounding = {{-144,-80},{144,-80},{144,80},{-144,80}}

		viewBoundingLen = #viewBounding

		viewBoundingInnerBoxL = 0
		viewBoundingInnerBoxR = 0
		viewBoundingInnerBoxT = 0
		viewBoundingInnerBoxB = 0
		
		depthScale = 0.0001
		depthMinimum = dist3({portalPrimary[1],camPos})
		depthOffset = depthMinimum-1
		
		
	endViewRenderingMaths:


	3 > viewBoundingLen ~ skipViewRendering

		cameraRotationMatrix = quaternionToMatrix({cameraRotationQuaternion})


		viewBoundingOuterBoxL = bigNum-0
		viewBoundingOuterBoxR = 0-bigNum
		viewBoundingOuterBoxT = bigNum-0
		viewBoundingOuterBoxB = 0-bigNum

		i=0
		outerBoundingBoxLoop:
		i = i+1
		cr = viewBounding[i]
		crX = cr[1]
		crY = cr[2]
		viewBoundingOuterBoxL = mn({crX,viewBoundingOuterBoxL})
		viewBoundingOuterBoxR = mx({crX,viewBoundingOuterBoxR})
		viewBoundingOuterBoxT = mn({crY,viewBoundingOuterBoxT})
		viewBoundingOuterBoxB = mx({crY,viewBoundingOuterBoxB})
		#viewBounding>i ~ outerBoundingBoxLoop




		culled = 0
		accepted = 0
		processed = 0
		
		junk = renderView({1})
	skipViewRendering:
3 > renderingPassGlobal ~ renderingLoop

exit






cameraRotationToQuaternion:

a=cameraRotation[1]/-2
b=cameraRotation[2]/-2
c=cameraRotation[3]/-2

cr = cos({b})
sr = sin({b})
cp = cos({a})
sp = sin({a})
cy = cos({c})
sy = sin({c})


cameraRotationQuaternion = {}
cameraRotationQuaternion[1] = cr * cp * cy + sr * sp * sy
cameraRotationQuaternion[2] = sr * cp * cy - cr * sp * sy
cameraRotationQuaternion[3] = cr * sp * cy + sr * cp * sy
cameraRotationQuaternion[4] = cr * cp * sy - sr * sp * cy

exit