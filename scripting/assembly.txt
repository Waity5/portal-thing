initFunc:

objects = {}

init = objects[1]

grav = {0,-9.81,0}

wheelbase = 2.7/2
trackwidth = 1.78/2


--junk = summonObject({"track1", {{0,-1,0},[7]=0,[8]=0}})
--junk = summonObject({"track2", {{0,-3,40},[7]=0,[8]=0}})
--junk = summonObject({"track3", {{5.5,-3,40},[7]=0,[8]=0}})
junk = summonObject({"widest_cube", {{0,-1,0},[7]=0,[8]=0}})
junk = summonObject({"skybox", {[7]=0,[8]=0}})
junk = summonObject({"blender_cube", {{0,1,11},[7]=0,[8]=0}})
junk = summonObject({"portal_orange", {{0,1,10},[7]=0,[8]=0}})
portalOrange = objects[#objects]

i = -3
summonBoxes:
	junk = summonObject({"blender_cube",{{10,1,i*5},[7]=1/1500,[8]=1/1500,[9]=grav}})
	i = i+1
4>i ~ summonBoxes

junk = summonObject({"hump",{{-10,0,0},[7]=0,[8]=0}})

springs = {} -- obj1, obj2, offset1, offset2, desired length, spring rate, dampen rate

exit





tickFunc:




moveSpeedInv = 1/moveSpeed
rotateSpeedInv = 1/rotateSpeed

gB31 = gB({31})
gB31 ~ holdingSpace
	camPos[1] = camPos[1] + (gN({1})*cos({camRot[1]}) - gN({2})*sin({camRot[1]})) / moveSpeedInv
	camPos[3] = camPos[3] + (gN({1})*sin({camRot[1]}) + gN({2})*cos({camRot[1]})) / moveSpeedInv
	maxPushForce = 0.5
	otherPushColours = 50
	1 ~ endCamMove
holdingSpace:
	camPos[2]=camPos[2] + gN({2}) / moveSpeedInv
	maxPushForce = 2.5
	otherPushColours = 0
endCamMove:

camRot[1]=camRot[1] - gN({3})/rotateSpeedInv
camRot[2]=camRot[2] + gN({4})/rotateSpeedInv

pushForce = 0
pushColour = {}
gB1 = gB({1})
gB1 ~ isGB1
gB3 = gB({3})
gB3 ~ isGB3
	pushColour[1] = 255
	pushColour[2] = 255
	pushColour[3] = 255
	1 ~ endOfPush
isGB1:
	pushForce = 0 - maxPushForce
	pushColour[1] = otherPushColours
	pushColour[2] = otherPushColours
	pushColour[3] = 255
	1 ~ endOfPush
isGB3:
	pushForce = maxPushForce - 0
	pushColour[1] = 255
	pushColour[2] = otherPushColours
	pushColour[3] = otherPushColours
endOfPush:




a=camRot[1]
b=camRot[2]
c_a = cos({a})
s_a = sin({a})
c_b = cos({b})
s_b = sin({b})

--cameraRotationMatrix = {}
--cameraRotationMatrix[1] = {c_a*c_c - s_a*s_b*s_c , 0-c_b*s_c , c_a*s_b*s_c + c_c*s_a}
--cameraRotationMatrix[2] = {c_a*s_c + c_c*s_a*s_b , c_b*c_c , s_a*s_c - c_a*c_c*s_b}
--cameraRotationMatrix[3] = {0-c_b*s_a , s_b , c_a*c_b}


cameraRotationVector = {0-s_a*c_b,s_b,c_a*c_b}

exit


postTransformFunc:


turn = turn*0.95 + gN({1})*0.05
turnCr = turn-0

turnS = sin({turnCr})/0.01
turnC = cos({turnCr})/0.01


pegPoints = {}






i = 0
pegPointsLen = #pegPoints
1 > pegPointsLen ~ pegPointLoopSkip
pegPointLoop:
	i = i + 1
	pegPoint = pegPoints[i]
	crPointLocal1 = pegPoint[4]
	crPointLocal2 = pegPoint[5]
	object1 = objects[pegPoint[1]]
	object2 = objects[pegPoint[2]]
	object3 = objects[pegPoint[3]]
	correctionDirection = pegPoint[6]
	correctionDirectionInverse = pegPoint[0]
	correctionDirection ~ correctionDirectionSkip1
		correctionDirectionInverse = 1
	correctionDirectionSkip1:
	
	correctionDirectionInverse ~ correctionDirectionSkip2
		correctionDirection = norm3({multVectorByMatrix({correctionDirection,object2[16]})})
	correctionDirectionSkip2:
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	totalDisplacement = sub3({crPoint1,crPoint2})
	correctionDirectionInverse ~ correctionDirectionSkip3
		totalDisplacement = sub3({totalDisplacement,mul3({correctionDirection,dot({totalDisplacement,correctionDirection})})})
	correctionDirectionSkip3:
	
	totalDistance = dist3({totalDisplacement,{0,0,0}})
	0.0001 > totalDistance ~ skipPegMovement
		totalDisplacementNormalised = norm3({totalDisplacement})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalDisplacementNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalDisplacementNormalised}))
		junk = applyInstantMovement({object1,crPoint1,mul3({totalDisplacement,-1/movementFromPushing})})
		junk = applyInstantMovement({object2,crPoint1,mul3({totalDisplacement,1/movementFromPushing})})
		
		object1[16] = quaternionToMatrix({object1[4]})
		object2[16] = quaternionToMatrix({object2[4]})
	skipPegMovement:
	
	
	
	crPoint1 = add3({multVectorByMatrix({crPointLocal1,object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({crPointLocal2,object2[16]}),object3[1]})
	
	velocity1 = add3({cross({object1[5],sub3({crPoint1,object1[1]})}),object1[2]})
	velocity2 = add3({cross({object2[5],sub3({crPoint2,object2[1]})}),object2[2]})
	totalVelocity = sub3({velocity1,velocity2})
	correctionDirectionInverse ~ correctionDirectionSkip4
		totalVelocity = sub3({totalVelocity,mul3({correctionDirection,dot({totalVelocity,correctionDirection})})})
	correctionDirectionSkip4:
	
	totalSpeed = dist3({totalVelocity,{0,0,0}})
	0.0001 > totalSpeed ~ skipPegForce
		totalVelocityNormalised = norm3({totalVelocity})
		movementFromPushing = getMovementPerUnitForce({object1,crPoint1,totalVelocityNormalised}) + (getMovementPerUnitForce({object2,crPoint1,totalVelocityNormalised}))
		junk = applyForce({object1,crPoint1,mul3({totalVelocity,-1/movementFromPushing})})
		junk = applyForce({object2,crPoint1,mul3({totalVelocity,1/movementFromPushing})})
	skipPegForce:
	
	--object1[16] = quaternionToMatrix({object1[4]}) -- not needed, previous section of code doesn't move objects
	--object2[16] = quaternionToMatrix({object2[4]})
pegPointsLen > i ~ pegPointLoop
pegPointLoopSkip:

i = 0
springsLen = #springs
1 > springsLen ~ springsLoopSkip
springsLoop:
	i = i + 1
	spring = springs[i]
	object1 = objects[spring[1]]
	object2 = objects[spring[2]]
	crPoint1 = add3({multVectorByMatrix({spring[3],object1[16]}),object1[1]})
	crPoint2 = add3({multVectorByMatrix({spring[4],object2[16]}),object2[1]})
	
	displacement = sub3({crPoint2,crPoint1})
	distance = dist3({displacement,{0,0,0}})
	displacementNormalised = mul3({displacement,1/distance})
	0.0001 > distance ~ skipSpringForce
		force = mul3({displacementNormalised,(spring[5]-distance)*spring[6]*deltaTime})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
		
		spring[8] ~ skipSpringInit
		spring[8] = distance
		skipSpringInit:
		
		force = mul3({displacementNormalised,(spring[8] - distance) * spring[7]})
		junk = applyForce({object1,crPoint1,mul3({force,-1})})
		junk = applyForce({object2,crPoint1,force})
	skipSpringForce:
	
	spring[8] = distance
springsLen > i ~ springsLoop
springsLoopSkip:

exit





renderCycleFunc:

renderingPassGlobal > 1 ~ secondViewRendering
	cameraPosition = {camPos}[1]
	cameraRotation = {camRot}[1]
	junk = executeScript({cameraRotationToQuaternion})

	--viewBounding = {{-90,-60},{100,-50},{100,50},{-100,50}}

	--viewBounding = {{0,-70},{100,-20},{50,70},{-50,70},{-100,-20}}
	viewBounding = {{-144,-80},{144,-80},{144,80},{-144,80}}

	viewBoundingLen = #viewBounding

	viewBoundingInnerBoxL = -144
	viewBoundingInnerBoxR = 144
	viewBoundingInnerBoxT = -80
	viewBoundingInnerBoxB = 80
	
	depthScale = 1
	depthOffset = 0
	
1 ~ endViewRendering
secondViewRendering:
	viewBounding = {}
	
	portalOrangeMesh = portalOrange[7]
	portalOrangeMeshLen = #portalOrangeMesh
	index1 = 0
	index2 = 0
	portalOrangeLoop:
		index1 = index1 + 1
		
		1 > portalOrangeMesh[index1][6] ~ skipCurrentPortalPoint
			index2 = index2 + 1
			viewBounding[index2] = portalOrangeMesh[index1][5]
		skipCurrentPortalPoint:
		
	portalOrangeMeshLen > index1 ~ portalOrangeLoop
	
	
	
	cameraRotation = {camRot}[1]
	
	junk = executeScript({cameraRotationToQuaternion})
	
	portalOrangeViewQuaternion = norm4({{0.5,0,-0.5,0}})
	portalOrangeViewQuaternionInverse = {0-portalOrangeViewQuaternion[1],portalOrangeViewQuaternion[2],portalOrangeViewQuaternion[3],portalOrangeViewQuaternion[4]}
	cameraRotationQuaternion = multQuaternionByQuaternion({portalOrangeViewQuaternionInverse, cameraRotationQuaternion})
	
	cameraPosition = add3({{-3,1,7}, multVectorByMatrix({sub3({camPos,portalOrange[1]}), quaternionToMatrix({portalOrangeViewQuaternion})})})
	

	--viewBounding = {{-90,-60},{100,-50},{100,50},{-100,50}}

	--viewBounding = {{0,-70},{100,-20},{50,70},{-50,70},{-100,-20}}
	--viewBounding = {{-144,-80},{144,-80},{144,80},{-144,80}}

	viewBoundingLen = #viewBounding

	viewBoundingInnerBoxL = 0
	viewBoundingInnerBoxR = 0
	viewBoundingInnerBoxT = 0
	viewBoundingInnerBoxB = 0
	
	depthScale = 0.0001
	depthOffset = dist3({portalOrange[1],camPos})-1
	
endViewRendering:




cameraRotationMatrix = quaternionToMatrix({cameraRotationQuaternion})


viewBoundingOuterBoxL = bigNum-0
viewBoundingOuterBoxR = 0-bigNum
viewBoundingOuterBoxT = bigNum-0
viewBoundingOuterBoxB = 0-bigNum

i=0
outerBoundingBoxLoop:
i = i+1
cr = viewBounding[i]
crX = cr[1]
crY = cr[2]
viewBoundingOuterBoxL = mn({crX,viewBoundingOuterBoxL})
viewBoundingOuterBoxR = mx({crX,viewBoundingOuterBoxR})
viewBoundingOuterBoxT = mn({crY,viewBoundingOuterBoxT})
viewBoundingOuterBoxB = mx({crY,viewBoundingOuterBoxB})
#viewBounding>i ~ outerBoundingBoxLoop




culled = 0
accepted = 0
processed = 0

exit






cameraRotationToQuaternion:

a=cameraRotation[1]/-2
b=cameraRotation[2]/-2
c=cameraRotation[3]/-2

cr = cos({b})
sr = sin({b})
cp = cos({a})
sp = sin({a})
cy = cos({c})
sy = sin({c})


cameraRotationQuaternion = {}
cameraRotationQuaternion[1] = cr * cp * cy + sr * sp * sy
cameraRotationQuaternion[2] = sr * cp * cy - cr * sp * sy
cameraRotationQuaternion[3] = cr * sp * cy + sr * cp * sy
cameraRotationQuaternion[4] = cr * cp * sy - sr * sp * cy

exit